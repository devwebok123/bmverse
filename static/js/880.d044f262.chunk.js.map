{"version":3,"file":"static/js/880.d044f262.chunk.js","mappings":"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","sources":["../node_modules/rxjs/src/internal/operators/audit.ts","../node_modules/rxjs/src/internal/operators/auditTime.ts","../node_modules/rxjs/src/internal/operators/buffer.ts","../node_modules/rxjs/src/internal/operators/bufferCount.ts","../node_modules/rxjs/src/internal/operators/bufferTime.ts","../node_modules/rxjs/src/internal/operators/bufferToggle.ts","../node_modules/rxjs/src/internal/operators/bufferWhen.ts","../node_modules/rxjs/src/internal/operators/catchError.ts","../node_modules/rxjs/src/internal/operators/combineAll.ts","../node_modules/rxjs/src/internal/operators/combineLatest.ts","../node_modules/rxjs/src/internal/operators/concat.ts","../node_modules/rxjs/src/internal/operators/concatMap.ts","../node_modules/rxjs/src/internal/operators/concatMapTo.ts","../node_modules/rxjs/src/internal/operators/count.ts","../node_modules/rxjs/src/internal/operators/debounce.ts","../node_modules/rxjs/src/internal/operators/debounceTime.ts","../node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts","../node_modules/rxjs/src/internal/util/isDate.ts","../node_modules/rxjs/src/internal/operators/delay.ts","../node_modules/rxjs/src/internal/operators/delayWhen.ts","../node_modules/rxjs/src/internal/operators/dematerialize.ts","../node_modules/rxjs/src/internal/operators/distinct.ts","../node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts","../node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts","../node_modules/rxjs/src/internal/operators/throwIfEmpty.ts","../node_modules/rxjs/src/internal/operators/take.ts","../node_modules/rxjs/src/internal/operators/elementAt.ts","../node_modules/rxjs/src/internal/operators/endWith.ts","../node_modules/rxjs/src/internal/operators/every.ts","../node_modules/rxjs/src/internal/operators/exhaust.ts","../node_modules/rxjs/src/internal/operators/exhaustMap.ts","../node_modules/rxjs/src/internal/operators/expand.ts","../node_modules/rxjs/src/internal/operators/finalize.ts","../node_modules/rxjs/src/internal/operators/find.ts","../node_modules/rxjs/src/internal/operators/findIndex.ts","../node_modules/rxjs/src/internal/operators/first.ts","../node_modules/rxjs/src/internal/operators/ignoreElements.ts","../node_modules/rxjs/src/internal/operators/isEmpty.ts","../node_modules/rxjs/src/internal/operators/takeLast.ts","../node_modules/rxjs/src/internal/operators/last.ts","../node_modules/rxjs/src/internal/operators/mapTo.ts","../node_modules/rxjs/src/internal/operators/materialize.ts","../node_modules/rxjs/src/internal/operators/scan.ts","../node_modules/rxjs/src/internal/operators/reduce.ts","../node_modules/rxjs/src/internal/operators/max.ts","../node_modules/rxjs/src/internal/operators/merge.ts","../node_modules/rxjs/src/internal/operators/mergeMapTo.ts","../node_modules/rxjs/src/internal/operators/mergeScan.ts","../node_modules/rxjs/src/internal/operators/min.ts","../node_modules/rxjs/src/internal/operators/multicast.ts","../node_modules/rxjs/src/internal/operators/onErrorResumeNext.ts","../node_modules/rxjs/src/internal/operators/pairwise.ts","../node_modules/rxjs/src/internal/operators/partition.ts","../node_modules/rxjs/src/internal/operators/pluck.ts","../node_modules/rxjs/src/internal/operators/publish.ts","../node_modules/rxjs/src/internal/operators/publishBehavior.ts","../node_modules/rxjs/src/internal/operators/publishLast.ts","../node_modules/rxjs/src/internal/operators/publishReplay.ts","../node_modules/rxjs/src/internal/operators/race.ts","../node_modules/rxjs/src/internal/operators/repeat.ts","../node_modules/rxjs/src/internal/operators/repeatWhen.ts","../node_modules/rxjs/src/internal/operators/retry.ts","../node_modules/rxjs/src/internal/operators/retryWhen.ts","../node_modules/rxjs/src/internal/operators/sample.ts","../node_modules/rxjs/src/internal/operators/sampleTime.ts","../node_modules/rxjs/src/internal/operators/sequenceEqual.ts","../node_modules/rxjs/src/internal/operators/share.ts","../node_modules/rxjs/src/internal/operators/shareReplay.ts","../node_modules/rxjs/src/internal/operators/single.ts","../node_modules/rxjs/src/internal/operators/skip.ts","../node_modules/rxjs/src/internal/operators/skipLast.ts","../node_modules/rxjs/src/internal/operators/skipUntil.ts","../node_modules/rxjs/src/internal/operators/skipWhile.ts","../node_modules/rxjs/src/internal/operators/startWith.ts","../node_modules/rxjs/src/internal/observable/SubscribeOnObservable.ts","../node_modules/rxjs/src/internal/operators/subscribeOn.ts","../node_modules/rxjs/src/internal/operators/switchMap.ts","../node_modules/rxjs/src/internal/operators/switchAll.ts","../node_modules/rxjs/src/internal/operators/switchMapTo.ts","../node_modules/rxjs/src/internal/operators/takeUntil.ts","../node_modules/rxjs/src/internal/operators/takeWhile.ts","../node_modules/rxjs/src/internal/operators/tap.ts","../node_modules/rxjs/src/internal/operators/throttle.ts","../node_modules/rxjs/src/internal/operators/throttleTime.ts","../node_modules/rxjs/src/internal/operators/timeInterval.ts","../node_modules/rxjs/src/internal/operators/timeoutWith.ts","../node_modules/rxjs/src/internal/operators/timeout.ts","../node_modules/rxjs/src/internal/operators/timestamp.ts","../node_modules/rxjs/src/internal/operators/toArray.ts","../node_modules/rxjs/src/internal/operators/window.ts","../node_modules/rxjs/src/internal/operators/windowCount.ts","../node_modules/rxjs/src/internal/operators/windowTime.ts","../node_modules/rxjs/src/internal/operators/windowToggle.ts","../node_modules/rxjs/src/internal/operators/windowWhen.ts","../node_modules/rxjs/src/internal/operators/withLatestFrom.ts","../node_modules/rxjs/src/internal/operators/zip.ts","../node_modules/rxjs/src/internal/operators/zipAll.ts","../node_modules/@babel/runtime/helpers/construct.js","../node_modules/@babel/runtime/helpers/isNativeFunction.js","../node_modules/@babel/runtime/helpers/wrapNativeSuper.js"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { audit } from 'rxjs/operators'\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private value?: T;\n  private hasValue: boolean = false;\n  private throttled?: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      let duration;\n      try {\n        const { durationSelector } = this;\n        duration = durationSelector(value);\n      } catch (err) {\n        return this.destination.error!(err);\n      }\n      const innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n      if (!innerSubscription || innerSubscription.closed) {\n        this.clearThrottle();\n      } else {\n        this.add(this.throttled = innerSubscription);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = undefined;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = undefined;\n      this.hasValue = false;\n      this.destination.next!(value);\n    }\n  }\n\n  notifyNext(): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n","import { async } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { auditTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { buffer } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nexport function buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]> {\n  return function bufferOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferOperator<T>(closingNotifier));\n  };\n}\n\nclass BufferOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingNotifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, closingNotifier: Observable<any>) {\n    super(destination);\n    this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n  }\n\n  protected _next(value: T) {\n    this.buffer.push(value);\n  }\n\n  notifyNext(): void {\n    const buffer = this.buffer;\n    this.buffer = [];\n    this.destination.next!(buffer);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferCount } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number = null): OperatorFunction<T, T[]> {\n  return function bufferCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferCountOperator<T>(bufferSize, startBufferEvery));\n  };\n}\n\nclass BufferCountOperator<T> implements Operator<T, T[]> {\n  private subscriberClass: any;\n\n  constructor(private bufferSize: number, private startBufferEvery: number) {\n    if (!startBufferEvery || bufferSize === startBufferEvery) {\n      this.subscriberClass = BufferCountSubscriber;\n    } else {\n      this.subscriberClass = BufferSkipCountSubscriber;\n    }\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): TeardownLogic {\n    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferCountSubscriber<T> extends Subscriber<T> {\n  private buffer: T[] = [];\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const buffer = this.buffer;\n\n    buffer.push(value);\n\n    if (buffer.length == this.bufferSize) {\n      this.destination.next(buffer);\n      this.buffer = [];\n    }\n  }\n\n  protected _complete(): void {\n    const buffer = this.buffer;\n    if (buffer.length > 0) {\n      this.destination.next(buffer);\n    }\n    super._complete();\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferSkipCountSubscriber<T> extends Subscriber<T> {\n  private buffers: Array<T[]> = [];\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T[]>, private bufferSize: number, private startBufferEvery: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const { bufferSize, startBufferEvery, buffers, count } = this;\n\n    this.count++;\n    if (count % startBufferEvery === 0) {\n      buffers.push([]);\n    }\n\n    for (let i = buffers.length; i--; ) {\n      const buffer = buffers[i];\n      buffer.push(value);\n      if (buffer.length === bufferSize) {\n        buffers.splice(i, 1);\n        this.destination.next(buffer);\n      }\n    }\n  }\n\n  protected _complete(): void {\n    const { buffers, destination } = this;\n\n    while (buffers.length > 0) {\n      let buffer = buffers.shift();\n      if (buffer.length > 0) {\n        destination.next(buffer);\n      }\n    }\n    super._complete();\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerAction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number | null | undefined, maxBufferSize: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { bufferTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: SchedulerLike = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ninterface DispatchCreateArg<T> {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number;\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface DispatchCloseArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: DispatchCreateArg<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule<DispatchCreateArg<T>>(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: SchedulerAction<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation<T>(this: SchedulerAction<DispatchCreateArg<T>>, state: DispatchCreateArg<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <SchedulerAction<DispatchCreateArg<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchCloseArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchCloseArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction, SubscribableOrPromise } from '../types';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { bufferToggle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle<T, O>(\n  openings: SubscribableOrPromise<O>,\n  closingSelector: (value: O) => SubscribableOrPromise<any>\n): OperatorFunction<T, T[]> {\n  return function bufferToggleOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));\n  };\n}\n\nclass BufferToggleOperator<T, O> implements Operator<T, T[]> {\n\n  constructor(private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  }\n}\n\ninterface BufferContext<T> {\n  buffer: T[];\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> {\n  private contexts: Array<BufferContext<T>> = [];\n\n  constructor(destination: Subscriber<T[]>,\n              openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) {\n    super(destination);\n    this.add(subscribeToResult(this, openings));\n  }\n\n  protected _next(value: T): void {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    for (let i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift()!;\n      context.subscription.unsubscribe();\n      context.buffer = null!;\n      context.subscription = null!;\n    }\n    this.contexts = null!;\n    super._error(err);\n  }\n\n  protected _complete(): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift()!;\n      this.destination.next!(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null!;\n      context.subscription = null!;\n    }\n    this.contexts = null!;\n    super._complete();\n  }\n\n  notifyNext(outerValue: any, innerValue: O): void {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, O>): void {\n    this.closeBuffer((<any> innerSub).context);\n  }\n\n  private openBuffer(value: O): void {\n    try {\n      const closingSelector = this.closingSelector;\n      const closingNotifier = closingSelector.call(this, value);\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private closeBuffer(context: BufferContext<T>): void {\n    const contexts = this.contexts;\n\n    if (contexts && context) {\n      const { buffer, subscription } = context;\n      this.destination.next!(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  }\n\n  private trySubscribe(closingNotifier: any): void {\n    const contexts = this.contexts;\n\n    const buffer: Array<T> = [];\n    const subscription = new Subscription();\n    const context = { buffer, subscription };\n    contexts.push(context);\n\n    const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      (innerSubscription as any).context = context;\n\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.png)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { bufferWhen } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferWhen(() =>\n *   interval(1000 + Math.random() * 4000)\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport function bufferWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, T[]> {\n  return function (source: Observable<T>) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nclass BufferWhenOperator<T> implements Operator<T, T[]> {\n\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferWhenSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n  private buffer?: T[];\n  private subscribing: boolean = false;\n  private closingSubscription?: Subscription;\n\n  constructor(destination: Subscriber<T[]>, private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openBuffer();\n  }\n\n  protected _next(value: T) {\n    this.buffer!.push(value);\n  }\n\n  protected _complete() {\n    const buffer = this.buffer;\n    if (buffer) {\n      this.destination.next!(buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.buffer = undefined;\n    this.subscribing = false;\n  }\n\n  notifyNext(): void {\n    this.openBuffer();\n  }\n\n  notifyComplete(): void {\n    if (this.subscribing) {\n      this.complete();\n    } else {\n      this.openBuffer();\n    }\n  }\n\n  openBuffer() {\n    let { closingSubscription } = this;\n\n    if (closingSubscription) {\n      this.remove(closingSubscription);\n      closingSubscription.unsubscribe();\n    }\n\n    const buffer = this.buffer;\n    if (this.buffer) {\n      this.destination.next!(buffer);\n    }\n\n    this.buffer = [];\n\n    let closingNotifier;\n    try {\n      const { closingSelector } = this;\n      closingNotifier = closingSelector();\n    } catch (err) {\n      return this.error(err);\n    }\n    closingSubscription = new Subscription();\n    this.closingSubscription = closingSubscription;\n    this.add(closingSubscription);\n    this.subscribing = true;\n    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));\n    this.subscribing = false;\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(selector: (err: any, caught: Observable<T>) => O): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * ![](catch.png)\n *\n * ## Examples\n * Continues with a different Observable when there's an error\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n * \t       throw 'four!';\n *       }\n *\t     return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V')),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retries the caught source Observable again in case of error, similar to retry() operator\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError, take } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *   \t   if (n === 4) {\n *   \t     throw 'four!';\n *       }\n * \t     return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30),\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throws a new error when the source Observable throws an error\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { map, catchError } from 'rxjs/operators';\n *\n * of(1, 2, 3, 4, 5).pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     }),\n *   )\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n *  @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | ObservedValueOf<O>> {\n    const operator = new CatchOperator(selector);\n    const caught = source.lift(operator);\n    return (operator.caught = caught as Observable<T>);\n  };\n}\n\nclass CatchOperator<T, R> implements Operator<T, T | R> {\n  caught: Observable<T>;\n\n  constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CatchSubscriber<T, R> extends SimpleOuterSubscriber<T, T | R> {\n  constructor(destination: Subscriber<any>,\n              private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>,\n              private caught: Observable<T>) {\n    super(destination);\n  }\n\n  // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n  error(err: any) {\n    if (!this.isStopped) {\n      let result: any;\n      try {\n        result = this.selector(err, this.caught);\n      } catch (err2) {\n        super.error(err2);\n        return;\n      }\n      this._unsubscribeAndRecycle();\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      this.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(result, innerSubscriber);\n      // The returned subscription will usually be the subscriber that was\n      // passed. However, interop subscribers will be wrapped and for\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n      if (innerSubscription !== innerSubscriber) {\n        this.add(innerSubscription);\n      }\n    }\n  }\n}\n","import { CombineLatestOperator } from '../observable/combineLatest';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\n\nexport function combineAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineAll<T>(): OperatorFunction<any, T[]>;\nexport function combineAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * ![](combineAll.png)\n *\n * `combineAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest}</a> strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ---\n *\n * ## Examples\n *\n * ### Map two click events to a finite interval Observable, then apply `combineAll`\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { map, combineAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(ev =>\n *      interval(Math.random() * 2000).pipe(take(3))\n *   ),\n *   take(2)\n * );\n * const result = higherOrder.pipe(\n *   combineAll()\n * );\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link mergeAll}\n *\n * @param {function(...values: Array<any>)} An optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return {Observable<T>}\n * @name combineAll\n */\nexport function combineAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new CombineLatestOperator(project));\n}\n","\nimport { isArray } from '../util/isArray';\nimport { CombineLatestOperator } from '../observable/combineLatest';\nimport { from } from '../observable/from';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\n/** @deprecated Deprecated in favor of static combineLatest. */\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link combineLatest}.\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(from([source, ...observables]), new CombineLatestOperator(project));\n}\n","import {  concat as concatStatic } from '../observable/concat';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static concat. */\nexport function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link concat}.\n */\nexport function concat<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(concatStatic(source, ...observables));\n}\n","import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) =>  O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function concatMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function concatMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) =>  O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { concatMap, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item emitted\n * by the source Observable and taking values from each projected inner\n * Observable sequentially.\n * @method concatMap\n * @owner Observable\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return mergeMap(project, resultSelector, 1);\n}\n","import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function concatMapTo<T, O extends ObservableInput<any>>(observable: O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport function concatMapTo<T, O extends ObservableInput<any>>(observable: O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated */\nexport function concatMapTo<T, R, O extends ObservableInput<any>>(observable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n * For each click event, tick every second from 0 to 3, with no concurrency\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { concatMapTo, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nexport function concatMapTo<T, R, O extends ObservableInput<any>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  return concatMap(() => innerObservable, resultSelector);\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Observer, OperatorFunction } from '../types';\nimport { Subscriber } from '../Subscriber';\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { count, takeUntil } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n * ```ts\n * import { range } from 'rxjs';\n * import { count } from 'rxjs/operators';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\n\nexport function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new CountOperator(predicate, source));\n}\n\nclass CountOperator<T> implements Operator<T, number> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<number>, source: any): any {\n    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CountSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n  private index: number = 0;\n\n  constructor(destination: Observer<number>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.predicate) {\n      this._tryPredicate(value);\n    } else {\n      this.count++;\n    }\n  }\n\n  private _tryPredicate(value: T) {\n    let result: any;\n\n    try {\n      result = this.predicate(value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.count++;\n    }\n  }\n\n  protected _complete(): void {\n    this.destination.next(this.count);\n    this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.png)\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { debounce } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounce(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nexport function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceOperator(durationSelector));\n}\n\nclass DebounceOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private value?: T;\n  private hasValue = false;\n  private durationSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    try {\n      const result = this.durationSelector.call(this, value);\n\n      if (result) {\n        this._tryNext(value, result);\n      }\n    } catch (err) {\n      this.destination.error!(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.emitValue();\n    this.destination.complete!();\n  }\n\n  private _tryNext(value: T, duration: SubscribableOrPromise<any>): void {\n    let subscription = this.durationSubscription;\n    this.value = value;\n    this.hasValue = true;\n    if (subscription) {\n      subscription.unsubscribe();\n      this.remove(subscription);\n    }\n\n    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n    if (subscription && !subscription.closed) {\n      this.add(this.durationSubscription = subscription);\n    }\n  }\n\n  notifyNext(): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue(): void {\n    if (this.hasValue) {\n      const value = this.value;\n      const subscription = this.durationSubscription;\n      if (subscription) {\n        this.durationSubscription = undefined;\n        subscription.unsubscribe();\n        this.remove(subscription);\n      }\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively if the duration selector Observable\n      // emits synchronously\n      this.value = undefined;\n      this.hasValue = false;\n      super._next(value!);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { debounceTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function defaultIfEmpty<T>(defaultValue?: T): MonoTypeOperatorFunction<T>;\nexport function defaultIfEmpty<T, R>(defaultValue?: R): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n * If no clicks happen in 5 seconds, then emit \"no clicks\"\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { defaultIfEmpty, takeUntil } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param {any} [defaultValue=null] The default value used if the source\n * Observable is empty.\n * @return {Observable} An Observable that emits either the specified\n * `defaultValue` if the source Observable emits no items, or the values emitted\n * by the source Observable.\n * @method defaultIfEmpty\n * @owner Observable\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R = null): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new DefaultIfEmptyOperator(defaultValue)) as Observable<T | R>;\n}\n\nclass DefaultIfEmptyOperator<T, R> implements Operator<T, T | R> {\n\n  constructor(private defaultValue: R) {\n  }\n\n  call(subscriber: Subscriber<T | R>, source: any): any {\n    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DefaultIfEmptySubscriber<T, R> extends Subscriber<T> {\n  private isEmpty: boolean = true;\n\n  constructor(destination: Subscriber<T | R>, private defaultValue: R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.isEmpty = false;\n    this.destination.next(value);\n  }\n\n  protected _complete(): void {\n    if (this.isEmpty) {\n      this.destination.next(this.defaultValue);\n    }\n    this.destination.complete();\n  }\n}\n","export function isDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(+value);\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.png)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n * Delay each click by one second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { delay } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: SchedulerLike;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: SchedulerAction<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: SchedulerLike): void {\n    this.active = true;\n    const destination = this.destination as Subscription;\n    destination.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n    this.unsubscribe();\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;\n/* tslint:disable:max-line-length */\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n * The completion of the notifier triggering the emission of the source value\n * is deprecated behavior and will be removed in future versions.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n * Delay each click by a random amount of time, between 0 and 5 seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { delayWhen } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(event => interval(Math.random() * 5000)),\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param {function(value: T, index: number): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>,\n                             subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    return (source: Observable<T>) =>\n      new SubscriptionDelayObservable(source, subscriptionDelay)\n        .lift(new DelayWhenOperator(delayDurationSelector));\n  }\n  return (source: Observable<T>) => source.lift(new DelayWhenOperator(delayDurationSelector));\n}\n\nclass DelayWhenOperator<T> implements Operator<T, T> {\n  constructor(private delayDurationSelector: (value: T, index: number) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelayWhenSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private completed: boolean = false;\n  private delayNotifierSubscriptions: Array<Subscription> = [];\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private delayDurationSelector: (value: T, index: number) => Observable<any>) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, _innerValue: any,\n             _outerIndex: number, _innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next!(outerValue);\n    this.removeSubscription(innerSub);\n    this.tryComplete();\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    const value = this.removeSubscription(innerSub);\n    if (value) {\n      this.destination.next!(value);\n    }\n    this.tryComplete();\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    try {\n      const delayNotifier = this.delayDurationSelector(value, index);\n      if (delayNotifier) {\n        this.tryDelay(delayNotifier, value);\n      }\n    } catch (err) {\n      this.destination.error!(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.completed = true;\n    this.tryComplete();\n    this.unsubscribe();\n  }\n\n  private removeSubscription(subscription: InnerSubscriber<T, R>): T {\n    subscription.unsubscribe();\n\n    const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n    if (subscriptionIdx !== -1) {\n      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n    }\n\n    return subscription.outerValue;\n  }\n\n  private tryDelay(delayNotifier: Observable<any>, value: T): void {\n    const notifierSubscription = subscribeToResult(this, delayNotifier, value);\n\n    if (notifierSubscription && !notifierSubscription.closed) {\n      const destination = this.destination as Subscription;\n      destination.add(notifierSubscription);\n      this.delayNotifierSubscriptions.push(notifierSubscription);\n    }\n  }\n\n  private tryComplete(): void {\n    if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n      this.destination.complete!();\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelayObservable<T> extends Observable<T> {\n  constructor(public source: Observable<T>, private subscriptionDelay: Observable<any>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SubscriptionDelaySubscriber<T> extends Subscriber<T> {\n  private sourceSubscribed: boolean = false;\n\n  constructor(private parent: Subscriber<T>, private source: Observable<T>) {\n    super();\n  }\n\n  protected _next(unused: any) {\n    this.subscribeToSource();\n  }\n\n  protected _error(err: any) {\n    this.unsubscribe();\n    this.parent.error(err);\n  }\n\n  protected _complete() {\n    this.unsubscribe();\n    this.subscribeToSource();\n  }\n\n  private subscribeToSource(): void {\n    if (!this.sourceSubscribed) {\n      this.sourceSubscribed = true;\n      this.unsubscribe();\n      this.source.subscribe(this.parent);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n * Convert an Observable of Notifications to an actual Observable\n * ```ts\n * import { of, Notification } from 'rxjs';\n * import { dematerialize } from 'rxjs/operators';\n *\n * const notifA = new Notification('N', 'A');\n * const notifB = new Notification('N', 'B');\n * const notifE = new Notification('E', undefined,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * const materialized = of(notifA, notifB, notifE);\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nexport function dematerialize<T>(): OperatorFunction<Notification<T>, T> {\n  return function dematerializeOperatorFunction(source: Observable<Notification<T>>) {\n    return source.lift(new DeMaterializeOperator());\n  };\n}\n\nclass DeMaterializeOperator<T extends Notification<any>, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<any>, source: any): any {\n    return source.subscribe(new DeMaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DeMaterializeSubscriber<T extends Notification<any>> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    value.observe(this.destination);\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n * A simple example with numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(\n *     distinct(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n * ```\n *\n * An example using a keySelector function\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinct } from 'rxjs/operators';\n *\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *   ).pipe(\n *     distinct((p: Person) => p.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K,\n                               flushes?: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctOperator(keySelector, flushes));\n}\n\nclass DistinctOperator<T, K> implements Operator<T, T> {\n  constructor(private keySelector?: (value: T) => K, private flushes?: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class DistinctSubscriber<T, K> extends SimpleOuterSubscriber<T, T> {\n  private values = new Set<K>();\n\n  constructor(destination: Subscriber<T>, private keySelector?: (value: T) => K, flushes?: Observable<any>) {\n    super(destination);\n\n    if (flushes) {\n      this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  notifyNext(): void {\n    this.values.clear();\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  protected _next(value: T): void {\n    if (this.keySelector) {\n      this._useKeySelector(value);\n    } else {\n      this._finalizeNext(value, value);\n    }\n  }\n\n  private _useKeySelector(value: T): void {\n    let key: K;\n    const { destination } = this;\n    try {\n      key = this.keySelector!(value);\n    } catch (err) {\n      destination.error!(err);\n      return;\n    }\n    this._finalizeNext(key, value);\n  }\n\n  private _finalizeNext(key: K|T, value: T) {\n    const { values } = this;\n    if (!values.has(<K>key)) {\n      values.add(<K>key);\n      this.destination.next!(value);\n    }\n  }\n\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Example\n * A simple example with numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { distinctUntilChanged } from 'rxjs/operators';\n *\n * of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4).pipe(\n *     distinctUntilChanged(),\n *   )\n *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n * ```\n *\n * An example using a compare function\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilChanged } from 'rxjs/operators';\n *\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'},\n *   ).pipe(\n *     distinctUntilChanged((p: Person, q: Person) => p.name === q.name),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinctUntilChanged\n * @owner Observable\n */\nexport function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));\n}\n\nclass DistinctUntilChangedOperator<T, K> implements Operator<T, T> {\n  constructor(private compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> {\n  private key: K;\n  private hasKey: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              compare: (x: K, y: K) => boolean,\n              private keySelector: (x: T) => K) {\n    super(destination);\n    if (typeof compare === 'function') {\n      this.compare = compare;\n    }\n  }\n\n  private compare(x: any, y: any): boolean {\n    return x === y;\n  }\n\n  protected _next(value: T): void {\n    let key: any;\n    try {\n      const { keySelector } = this;\n      key = keySelector ? keySelector(value) : value;\n    } catch (err) {\n      return this.destination.error(err);\n    }\n    let result = false;\n    if (this.hasKey) {\n      try {\n        const { compare } = this;\n        result = compare(this.key, key);\n      } catch (err) {\n        return this.destination.error(err);\n      }\n    } else {\n      this.hasKey = true;\n    }\n    if (!result) {\n      this.key = key;\n      this.destination.next(value);\n    }\n  }\n}\n","import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n * An example comparing the name of persons\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilKeyChanged } from 'rxjs/operators';\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'},\n *   ).pipe(\n *     distinctUntilKeyChanged('name'),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n * ```typescript\n * import { of } from 'rxjs';\n * import { distinctUntilKeyChanged } from 'rxjs/operators';\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'},\n *   ).pipe(\n *     distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3)),\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare?: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => compare ? compare(x[key], y[key]) : x[key] === y[key]);\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic, MonoTypeOperatorFunction } from '../types';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n * ```ts\n * import { fromEvent, timer } from 'rxjs';\n * import { throwIfEmpty, takeUntil } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(\n *     () => new Error('the document was not clicked within 1 second')\n *   ),\n * )\n * .subscribe({\n *   next() { console.log('The button was clicked'); },\n *   error(err) { console.error(err); }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n */\nexport function throwIfEmpty <T>(errorFactory: (() => any) = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    return source.lift(new ThrowIfEmptyOperator(errorFactory));\n  };\n}\n\nclass ThrowIfEmptyOperator<T> implements Operator<T, T> {\n  constructor(private errorFactory: () => any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));\n  }\n}\n\nclass ThrowIfEmptySubscriber<T> extends Subscriber<T> {\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>, private errorFactory: () => any) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.hasValue = true;\n    this.destination.next(value);\n  }\n\n  protected _complete() {\n    if (!this.hasValue) {\n      let err: any;\n      try {\n        err = this.errorFactory();\n      } catch (e) {\n        err = e;\n      }\n      this.destination.error(err);\n    } else {\n        return this.destination.complete();\n    }\n  }\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n * Take the first 5 seconds of an infinite 1-second interval Observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n * Emit only the third click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { elementAt } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nexport function elementAt<T>(index: number, defaultValue?: T): MonoTypeOperatorFunction<T> {\n  if (index < 0) { throw new ArgumentOutOfRangeError(); }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    filter((v, i) => i === index),\n    take(1),\n    hasDefaultValue\n      ? defaultIfEmpty(defaultValue)\n      : throwIfEmpty(() => new ArgumentOutOfRangeError()),\n  );\n}\n","import { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A>(v1: A, scheduler: SchedulerLike): OperatorFunction<T, T | A>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B>(v1: A, v2: B, scheduler: SchedulerLike): OperatorFunction<T, T | A | B>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C>(v1: A, v2: B, v3: C, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F, scheduler: SchedulerLike): OperatorFunction<T, T | A | B | C | D | E | F>;\n\nexport function endWith<T, A>(v1: A): OperatorFunction<T, T | A>;\nexport function endWith<T, A, B>(v1: A, v2: B): OperatorFunction<T, T | A | B>;\nexport function endWith<T, A, B, C>(v1: A, v2: B, v3: C): OperatorFunction<T, T | A | B | C>;\nexport function endWith<T, A, B, C, D>(v1: A, v2: B, v3: C, v4: D): OperatorFunction<T, T | A | B | C | D>;\nexport function endWith<T, A, B, C, D, E>(v1: A, v2: B, v3: C, v4: D, v5: E): OperatorFunction<T, T | A | B | C | D | E>;\nexport function endWith<T, A, B, C, D, E, F>(v1: A, v2: B, v3: C, v4: D, v5: E, v6: F): OperatorFunction<T, T | A | B | C | D | E | F>;\nexport function endWith<T, Z = T>(...array: Z[]): OperatorFunction<T, T | Z>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([source, [a, b, c]], scheduler).pipe(concatAll())`) */\nexport function endWith<T, Z = T>(...array: Array<Z | SchedulerLike>): OperatorFunction<T, T | Z>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments after it finishes emitting\n * items emitted by the source Observable.\n *\n * ![](endWith.png)\n *\n * ## Example\n * ### After the source observable completes, appends an emission and then completes too.\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { endWith } from 'rxjs/operators';\n *\n * of('hi', 'how are you?', 'sorry, I have to go now').pipe(\n *   endWith('goodbye!'),\n * )\n * .subscribe(word => console.log(word));\n * // result:\n * // 'hi'\n * // 'how are you?'\n * // 'sorry, I have to go now'\n * // 'goodbye!'\n * ```\n *\n * @param {...T} values - Items you want the modified Observable to emit last.\n * @param {SchedulerLike} [scheduler] - A {@link SchedulerLike} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items emitted by the source Observable\n *  and then emits the items in the specified Iterable.\n * @method endWith\n * @owner Observable\n */\nexport function endWith<T>(...array: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...array)) as Observable<T>;\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * ## Example\n * A simple example emitting true if all elements are less than 5, false otherwise\n * ```ts\n * import { of } from 'rxjs';\n * import { every } from 'rxjs/operators';\n *\n *  of(1, 2, 3, 4, 5, 6).pipe(\n *     every(x => x < 5),\n * )\n * .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param {function} predicate A function for determining if an item meets a specified condition.\n * @param {any} [thisArg] Optional object to use for `this` in the callback.\n * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n * @method every\n * @owner Observable\n */\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         thisArg?: any): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new EveryOperator(predicate, thisArg, source));\n}\n\nclass EveryOperator<T> implements Operator<T, boolean> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass EverySubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Observer<boolean>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private thisArg: any,\n              private source?: Observable<T>) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  private notifyComplete(everyValueMatch: boolean): void {\n    this.destination.next(everyValueMatch);\n    this.destination.complete();\n  }\n\n  protected _next(value: T): void {\n    let result = false;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (!result) {\n      this.notifyComplete(false);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\nexport function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function exhaust<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaust.png)\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { exhaust, map, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(5))),\n * );\n * const result = higherOrder.pipe(exhaust());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nexport function exhaust<T>(): OperatorFunction<any, T> {\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\n}\n\nclass SwitchFirstOperator<T> implements Operator<T, T> {\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstSubscriber<T> extends SimpleOuterSubscriber<T, T> {\n  private hasCompleted: boolean = false;\n  private hasSubscription: boolean = false;\n\n  constructor(destination: Subscriber<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete!();\n    }\n  }\n\n  notifyComplete(): void {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported. Use inner map instead. */\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n * Run a finite timer for each click, only if there is no currently active timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { exhaustMap, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(ev => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      exhaustMap((a, i) => from(project(a, i)).pipe(\n        map((b: any, ii: any) => resultSelector(a, b, i, ii)),\n      )),\n    );\n  }\n  return (source: Observable<T>) =>\n    source.lift(new ExhaustMapOperator(project));\n}\n\nclass ExhaustMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ExhaustMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasSubscription = false;\n  private hasCompleted = false;\n  private index = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.hasSubscription = true;\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    this.destination.next!(innerValue);\n  }\n\n  notifyError(err: any): void {\n    this.destination.error!(err);\n  }\n\n  notifyComplete(): void {\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput, SchedulerLike } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, R>;\nexport function expand<T>(project: (value: T, index: number) => ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n * Start emitting the powers of two on every click, at most 10 of them\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { expand, mapTo, delay, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   mapTo(1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10),\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand<T, R>(project: (value: T, index: number) => ObservableInput<R>,\n                             concurrent: number = Number.POSITIVE_INFINITY,\n                             scheduler?: SchedulerLike): OperatorFunction<T, R> {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n\n  return (source: Observable<T>) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\n\nexport class ExpandOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler?: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n}\n\ninterface DispatchArg<T, R> {\n  subscriber: ExpandSubscriber<T, R>;\n  result: ObservableInput<R>;\n  value: any;\n  index: number;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ExpandSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index: number = 0;\n  private active: number = 0;\n  private hasCompleted: boolean = false;\n  private buffer?: any[];\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number,\n              private scheduler?: SchedulerLike) {\n    super(destination);\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  private static dispatch<T, R>(arg: DispatchArg<T, R>): void {\n    const {subscriber, result, value, index} = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  protected _next(value: any): void {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n      return;\n    }\n\n    const index = this.index++;\n    if (this.active < this.concurrent) {\n      destination.next!(value);\n      try {\n        const { project } = this;\n        const result = project(value, index);\n        if (!this.scheduler) {\n          this.subscribeToProjection(result, value, index);\n        } else {\n          const state: DispatchArg<T, R> = { subscriber: this, result, value, index };\n          const destination = this.destination as Subscription;\n          destination.add(this.scheduler.schedule<DispatchArg<T, R>>(ExpandSubscriber.dispatch as any, 0, state));\n        }\n      } catch (e) {\n        destination.error!(e);\n      }\n    } else {\n      this.buffer!.push(value);\n    }\n  }\n\n  private subscribeToProjection(result: any, value: T, index: number): void {\n    this.active++;\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    this._next(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete!();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new FinallyOperator(callback));\n}\n\nclass FinallyOperator<T> implements Operator<T, T> {\n  constructor(private callback: () => void) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FinallySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<T>, callback: () => void) {\n    super(destination);\n    this.add(new Subscription(callback));\n  }\n}\n","import {Observable} from '../Observable';\nimport {Operator} from '../Operator';\nimport {Subscriber} from '../Subscriber';\nimport {OperatorFunction} from '../types';\n\nexport function find<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                     thisArg?: any): OperatorFunction<T, S | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * ## Example\n * Find and emit the first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { find } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                        thisArg?: any): OperatorFunction<T, T | undefined> {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, false, thisArg)) as Observable<T | undefined>;\n}\n\nexport class FindValueOperator<T> implements Operator<T, T | number | undefined> {\n  constructor(private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n  }\n\n  call(observer: Subscriber<T>, source: any): any {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class FindValueSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number, source: Observable<T>) => boolean,\n              private source: Observable<T>,\n              private yieldIndex: boolean,\n              private thisArg?: any) {\n    super(destination);\n  }\n\n  private notifyComplete(value: any): void {\n    const destination = this.destination;\n\n    destination.next(value);\n    destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    const {predicate, thisArg} = this;\n    const index = this.index++;\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n}\n","import { Observable } from '../Observable';\nimport { FindValueOperator } from '../operators/find';\nimport { OperatorFunction } from '../types';\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n * Emit the index of first click that happens on a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { findIndex } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                             thisArg?: any): OperatorFunction<T, number> {\n  return (source: Observable<T>) => source.lift(new FindValueOperator(predicate, source, true, thisArg)) as Observable<any>;\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction } from '../../internal/types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\n/* tslint:disable:max-line-length */\nexport function first<T, D = T>(\n  predicate?: null,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a deprecated `resultSelector` function to produce the output\n * value from the input value, and a `defaultValue` to emit in case the source\n * completes before it is able to emit a valid value. Throws an error if\n * `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n * Emit only the first click that happens on the DOM\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { first } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { first } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => ev.target.tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n    take(1),\n    hasDefaultValue ? defaultIfEmpty<T | D>(defaultValue) : throwIfEmpty(() => new EmptyError()),\n  );\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * ## Examples\n * ### Ignores emitted values, reacts to observable's completion.\n * ```ts\n * import { of } from 'rxjs';\n * import { ignoreElements } from 'rxjs/operators';\n *\n * of('you', 'talking', 'to', 'me').pipe(\n *   ignoreElements(),\n * )\n * .subscribe(\n *   word => console.log(word),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'the end'\n * ```\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nexport function ignoreElements(): OperatorFunction<any, never> {\n  return function ignoreElementsOperatorFunction(source: Observable<any>) {\n    return source.lift(new IgnoreElementsOperator());\n  };\n}\n\nclass IgnoreElementsOperator<T, R> implements Operator<T, R> {\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IgnoreElementsSubscriber<T> extends Subscriber<T> {\n  protected _next(unused: T): void {\n    // Do nothing\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits false if the input observable emits any values, or emits true if the\n * input observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an observable</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n * ```javascript\n * import { Subject } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Results in:\n * // a\n * // false\n * // b\n * // c\n * ```\n *\n * Emit `true` for an empty Observable\n * ```javascript\n * import { EMPTY } from 'rxjs';\n * import { isEmpty } from 'rxjs/operators';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return {OperatorFunction<T, boolean>} An Observable of a boolean value indicating whether observable was empty or not\n * @method isEmpty\n * @owner Observable\n */\n\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new IsEmptyOperator());\n}\n\nclass IsEmptyOperator implements Operator<any, boolean> {\n  call (observer: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new IsEmptySubscriber(observer));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass IsEmptySubscriber extends Subscriber<any> {\n  constructor(destination: Subscriber<boolean>) {\n    super(destination);\n  }\n\n  private notifyComplete(isEmpty: boolean): void {\n    const destination = this.destination;\n\n    destination.next(isEmpty);\n    destination.complete();\n  }\n\n  protected _next(value: boolean) {\n    this.notifyComplete(false);\n  }\n\n  protected _complete() {\n    this.notifyComplete(true);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the last `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\n * only when the source completes.</span>\n *\n * ![](takeLast.png)\n *\n * `takeLast` returns an Observable that emits at most the last `count` values\n * emitted by the source Observable. If the source emits fewer than `count`\n * values then all of its values are emitted. This operator must wait until the\n * `complete` notification emission from the source in order to emit the `next`\n * values on the output Observable, because otherwise it is impossible to know\n * whether or not more values will be emitted on the source. For this reason,\n * all values are emitted synchronously, followed by the complete notification.\n *\n * ## Example\n * Take the last 3 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { takeLast } from 'rxjs/operators';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits at most the last count\n * values emitted by the source Observable.\n * @method takeLast\n * @owner Observable\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return function takeLastOperatorFunction(source: Observable<T>): Observable<T> {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nclass TakeLastOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeLastSubscriber<T> extends Subscriber<T> {\n  private ring: Array<T> = new Array();\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const ring = this.ring;\n    const total = this.total;\n    const count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      const index = count % total;\n      ring[index] = value;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    let count = this.count;\n\n    if (count > 0) {\n      const total = this.count >= this.total ? this.total : this.count;\n      const ring  = this.ring;\n\n      for (let i = 0; i < total; i++) {\n        const idx = (count++) % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction } from '../../internal/types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\n/* tslint:disable:max-line-length */\nexport function last<T, D = T>(\n  predicate?: null,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {function} [predicate] - The condition any source emitted item has to satisfy.\n * @param {any} [defaultValue] - An optional default value to provide if last\n * predicate isn't met or no values were emitted.\n * @return {Observable} An Observable that emits only the last item satisfying the given condition\n * from the source, or an NoSuchElementException if no such items are emitted.\n * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) => source.pipe(\n    predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n    takeLast(1),\n    hasDefaultValue ? defaultIfEmpty<T | D>(defaultValue) : throwIfEmpty(() => new EmptyError()),\n  );\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n * Map every click to the string 'Hi'\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\n}\n\nclass MapToOperator<T, R> implements Operator<T, R> {\n\n  value: R;\n\n  constructor(value: R) {\n    this.value = value;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapToSubscriber<T, R> extends Subscriber<T> {\n\n  value: R;\n\n  constructor(destination: Subscriber<R>, value: R) {\n    super(destination);\n    this.value = value;\n  }\n\n  protected _next(x: T) {\n    this.destination.next(this.value);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { OperatorFunction } from '../types';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n * Convert a faulty Observable to an Observable of Notifications\n * ```ts\n * import { of } from 'rxjs';\n * import { materialize, map } from 'rxjs/operators';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map(x => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1, hasValue: false}\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T>> {\n  return function materializeOperatorFunction(source: Observable<T>) {\n    return source.lift(new MaterializeOperator());\n  };\n}\n\nclass MaterializeOperator<T> implements Operator<T, Notification<T>> {\n  call(subscriber: Subscriber<Notification<T>>, source: any): any {\n    return source.subscribe(new MaterializeSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MaterializeSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<Notification<T>>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.destination.next(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    const destination = this.destination;\n    destination.next(Notification.createError(err));\n    destination.complete();\n  }\n\n  protected _complete() {\n    const destination = this.destination;\n    destination.next(Notification.createComplete());\n    destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed: R): OperatorFunction<T, R>;\nexport function scan<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * ![](scan.png)\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { scan, mapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const ones = clicks.pipe(mapTo(1));\n * const seed = 0;\n * const count = ones.pipe(scan((acc, one) => acc + one, seed));\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nexport function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: T | R): OperatorFunction<T, R> {\n  let hasSeed = false;\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    hasSeed = true;\n  }\n\n  return function scanOperatorFunction(source: Observable<T>): Observable<R> {\n    return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n  };\n}\n\nclass ScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => R, private seed?: T | R, private hasSeed: boolean = false) {}\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ScanSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n\n  get seed(): T | R {\n    return this._seed;\n  }\n\n  set seed(value: T | R) {\n    this.hasSeed = true;\n    this._seed = value;\n  }\n\n  constructor(destination: Subscriber<R>, private accumulator: (acc: R, value: T, index: number) => R, private _seed: T | R,\n              private hasSeed: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSeed) {\n      this.seed = value;\n      this.destination.next(value);\n    } else {\n      return this._tryNext(value);\n    }\n  }\n\n  private _tryNext(value: T): void {\n    const index = this.index++;\n    let result: any;\n    try {\n      result = this.accumulator(<R>this.seed, value, index);\n    } catch (err) {\n      this.destination.error(err);\n    }\n    this.seed = result;\n    this.destination.next(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { scan } from './scan';\nimport { takeLast } from './takeLast';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../types';\nimport { pipe } from '../util/pipe';\n\n/* tslint:disable:max-line-length */\nexport function reduce<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed: R): OperatorFunction<T, R>;\nexport function reduce<T>(accumulator: (acc: T, value: T, index: number) => T, seed?: T): MonoTypeOperatorFunction<T>;\nexport function reduce<T, R>(accumulator: (acc: R, value: T, index: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * ![](reduce.png)\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n * Count the number of click events that happened in 5 seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { reduce, takeUntil, mapTo } from 'rxjs/operators';\n *\n * const clicksInFiveSeconds = fromEvent(document, 'click').pipe(\n *   takeUntil(interval(5000)),\n * );\n * const ones = clicksInFiveSeconds.pipe(mapTo(1));\n * const seed = 0;\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n * called on each source value.\n * @param {R} [seed] The initial accumulation value.\n * @return {Observable<R>} An Observable that emits a single value that is the\n * result of accumulating the values emitted by the source Observable.\n * @method reduce\n * @owner Observable\n */\nexport function reduce<T, R>(accumulator: (acc: T | R, value: T, index?: number) => T | R, seed?: T | R): OperatorFunction<T, T | R> {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  if (arguments.length >= 2) {\n    return function reduceOperatorFunctionWithSeed(source: Observable<T>): Observable<T | R> {\n      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);\n    };\n  }\n  return function reduceOperatorFunction(source: Observable<T>): Observable<T | R> {\n    return pipe(\n      scan<T, T | R>((acc, value, index) => accumulator(acc, value, index + 1)),\n      takeLast(1),\n    )(source);\n  };\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n * Get the maximal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   max(),\n * )\n * .subscribe(x => console.log(x)); // -> 8\n * ```\n *\n * Use a comparer function to get the maximal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { max } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  const max: (x: T, y: T) => T = (typeof comparer === 'function')\n    ? (x, y) => comparer(x, y) > 0 ? x : y\n    : (x, y) => x > y ? x : y;\n\n  return reduce(max);\n}\n","import { merge as mergeStatic } from '../observable/merge';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction, MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(concurrent?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2>(v2: ObservableInput<T2>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T>(...observables: Array<ObservableInput<T> | SchedulerLike | number>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static merge. */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link merge}.\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift.call(mergeStatic(source, ...observables));\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction, ObservedValueOf } from '../../internal/types';\nimport { mergeMap } from './mergeMap';\nimport { ObservableInput } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function mergeMapTo<T, O extends ObservableInput<any>>(innerObservable: O, concurrent?: number): OperatorFunction<any, ObservedValueOf<O>>;\n/** @deprecated */\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(innerObservable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n * For each click event, start an interval Observable ticking every 1 second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { mergeMapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable`\n * @method mergeMapTo\n * @owner Observable\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * ## Example\n * Count the number of click events\n * ```ts\n * import { fromEvent, of } from 'rxjs';\n * import { mapTo, mergeScan } from 'rxjs/operators';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(mapTo(1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed),\n * );\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const destination = this.destination;\n      let ish;\n      try {\n        const { accumulator } = this;\n        ish = accumulator(this.acc, value, index);\n      } catch (e) {\n        return destination.error!(e);\n      }\n      this.active++;\n      this._innerSub(ish);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(ish, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next!(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next!(this.acc);\n      }\n      this.destination.complete!();\n    }\n  }\n}\n","import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\n\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n * Get the minimal value of a series of numbers\n * ```ts\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * of(5, 4, 7, 2, 8).pipe(\n *   min(),\n * )\n * .subscribe(x => console.log(x)); // -> 2\n * ```\n *\n * Use a comparer function to get the minimal item\n * ```typescript\n * import { of } from 'rxjs';\n * import { min } from 'rxjs/operators';\n *\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * of<Person>(\n *   {age: 7, name: 'Foo'},\n *   {age: 5, name: 'Bar'},\n *   {age: 9, name: 'Beer'},\n * ).pipe(\n *   min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1),\n * )\n * .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * ```\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  const min: (x: T, y: T) => T = (typeof comparer === 'function')\n    ? (x, y) => comparer(x, y) < 0 ? x : y\n    : (x, y) => x < y ? x : y;\n  return reduce(min);\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;\nexport function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * ![](multicast.png)\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","import { Observable } from '../Observable';\nimport { from } from '../observable/from';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isArray } from '../util/isArray';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNext<T>(): OperatorFunction<T, T>;\nexport function onErrorResumeNext<T, T2>(v: ObservableInput<T2>): OperatorFunction<T, T | T2>;\nexport function onErrorResumeNext<T, T2, T3>(v: ObservableInput<T2>, v2: ObservableInput<T3>): OperatorFunction<T, T | T2 | T3>;\nexport function onErrorResumeNext<T, T2, T3, T4>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>): OperatorFunction<T, T | T2 | T3 | T4>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, T7>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>, v6: ObservableInput<T7>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any>>): OperatorFunction<T, T | R>;\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n * Subscribe to the next Observable after map fails\n * ```ts\n * import { of } from 'rxjs';\n * import { onErrorResumeNext, map } from 'rxjs/operators';\n *\n * of(1, 2, 3, 0).pipe(\n *   map(x => {\n *       if (x === 0) { throw Error(); }\n *        return 10 / x;\n *   }),\n *   onErrorResumeNext(of(1, 2, 3)),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('that\\'s it!')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\n\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\n                                                       Array<ObservableInput<any>>>): OperatorFunction<T, R> {\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = <Array<Observable<any>>>nextSources[0];\n  }\n\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\n/* tslint:disable:max-line-length */\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\n\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\n/* tslint:enable:max-line-length */\n\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\n  Array<ObservableInput<any>> |\n  ((...values: Array<any>) => R)>): Observable<R> {\n  let source: ObservableInput<any>|undefined = undefined;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0] as ObservableInput<any>[];\n  }\n  // TODO: resolve issue with passing no arguments.\n  source = nextSources.shift()!;\n\n  return from(source).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\n}\n\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\n  constructor(private nextSources: Array<ObservableInput<any>>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  }\n}\n\nclass OnErrorResumeNextSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  constructor(protected destination: Subscriber<T>,\n              private nextSources: Array<ObservableInput<any>>) {\n    super(destination);\n  }\n\n  notifyError(): void {\n    this.subscribeToNextSource();\n  }\n\n  notifyComplete(): void {\n    this.subscribeToNextSource();\n  }\n\n  protected _error(err: any): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  }\n\n  private subscribeToNextSource(): void {\n    const next = this.nextSources.shift();\n    if (!!next) {\n      const innerSubscriber = new SimpleInnerSubscriber(this);\n      const destination = this.destination as Subscription;\n      destination.add(innerSubscriber);\n      const innerSubscription = innerSubscribe(next, innerSubscriber);\n      // The returned subscription will usually be the subscriber that was\n      // passed. However, interop subscribers will be wrapped and for\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n      if (innerSubscription !== innerSubscriber) {\n        destination.add(innerSubscription);\n      }\n    } else {\n      this.destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n * On every click (starting from the second), emit the relative distance to the previous click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { pairwise, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(pair => {\n *     const x0 = pair[0].clientX;\n *     const y0 = pair[0].clientY;\n *     const x1 = pair[1].clientX;\n *     const y1 = pair[1].clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   }),\n * );\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n * @method pairwise\n * @owner Observable\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return (source: Observable<T>) => source.lift(new PairwiseOperator());\n}\n\nclass PairwiseOperator<T> implements Operator<T, [T, T]> {\n  call(subscriber: Subscriber<[T, T]>, source: any): any {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass PairwiseSubscriber<T> extends Subscriber<T> {\n  private prev: T;\n  private hasPrev: boolean = false;\n\n  constructor(destination: Subscriber<[T, T]>) {\n    super(destination);\n  }\n\n  _next(value: T): void {\n    let pair: [T, T] | undefined;\n\n    if (this.hasPrev) {\n      pair = [this.prev, value];\n    } else {\n      this.hasPrev = true;\n    }\n\n    this.prev = value;\n\n    if (pair) {\n      this.destination.next(pair);\n    }\n  }\n}\n","import { not } from '../util/not';\nimport { filter } from './filter';\nimport { Observable } from '../Observable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n * Partition click events into those on DIV elements and those elsewhere\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { partition } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const parts = clicks.pipe(partition(ev => ev.target.tagName === 'DIV'));\n * const clicksOnDivs = parts[0];\n * const clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n * ```\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n * @deprecated use `partition` static creation function instead\n */\nexport function partition<T>(predicate: (value: T, index: number) => boolean,\n                             thisArg?: any): UnaryFunction<Observable<T>, [Observable<T>, Observable<T>]> {\n  return (source: Observable<T>) => [\n    filter(predicate, thisArg)(source),\n    filter(not(predicate, thisArg) as any)(source)\n  ] as [Observable<T>, Observable<T>];\n}\n","import { Observable } from '../Observable';\nimport { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n * Map every click to the tagName of the clicked target element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { pluck } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return (source: Observable<T>) => map(plucker(properties, length))(source as any);\n}\n\nfunction plucker(props: string[], length: number): (x: string) => any {\n  const mapper = (x: string) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp != null ? currentProp[props[i]] : undefined;\n      if (p !== void 0) {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  };\n\n  return mapper;\n}\n","import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\nexport function publish<T>(selector: MonoTypeOperatorFunction<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n * Make source$ hot by applying publish operator, then merge each inner observable into a single one\n * and subscribe.\n * ```ts\n * import { of, zip, interval, merge } from \"rxjs\";\n * import { map, publish, tap } from \"rxjs/operators\";\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9)).pipe(\n *   map(values => values[1])\n * );\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x))),\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n *\n *\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ?\n    multicast(() => new Subject<T>(), selector) :\n    multicast(new Subject<T>());\n}\n","import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nexport function publishBehavior<T>(value: T):  UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  return (source: Observable<T>) => multicast(new BehaviorSubject<T>(value))(source) as ConnectableObservable<T>;\n}\n","import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { publishLast, tap, take } from 'rxjs/operators';\n *\n * const connectable =\n *   interval(1000)\n *     .pipe(\n *       tap(x => console.log(\"side effect\", x)),\n *       take(3),\n *       publishLast());\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. A\", x),\n *   err => console.log(\"Sub. A Error\", err),\n *   () => console.log( \"Sub. A Complete\"));\n *\n * connectable.subscribe(\n *   x => console.log(  \"Sub. B\", x),\n *   err => console.log(\"Sub. B Error\", err),\n *   () => console.log( \"Sub. B Complete\"));\n *\n * connectable.connect();\n *\n * // Results:\n * //    \"side effect 0\"\n * //    \"side effect 1\"\n * //    \"side effect 2\"\n * //    \"Sub. A 2\"\n * //    \"Sub. B 2\"\n * //    \"Sub. A Complete\"\n * //    \"Sub. B Complete\"\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return {ConnectableObservable} An observable sequence that contains the elements of a\n * sequence produced by multicasting the source sequence.\n * @method publishLast\n * @owner Observable\n */\n\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  return (source: Observable<T>) => multicast(new AsyncSubject<T>())(source);\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction, MonoTypeOperatorFunction, OperatorFunction, SchedulerLike, ObservableInput, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\nexport function publishReplay<T, O extends ObservableInput<any>>(bufferSize?: number, windowTime?: number, selector?: (shared: Observable<T>) => O, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\nexport function publishReplay<T, R>(bufferSize?: number,\n                                    windowTime?: number,\n                                    selectorOrScheduler?: SchedulerLike | OperatorFunction<T, R>,\n                                    scheduler?: SchedulerLike): UnaryFunction<Observable<T>, ConnectableObservable<R>> {\n\n  if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n    scheduler = selectorOrScheduler;\n  }\n\n  const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n  const subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n\n  return (source: Observable<T>) => multicast(() => subject, selector)(source) as ConnectableObservable<R>;\n}\n","import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { race as raceStatic } from '../observable/race';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>;\n/** @deprecated Deprecated in favor of static race. */\nexport function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n * @deprecated Deprecated in favor of static {@link race}.\n */\nexport function race<T>(...observables: (Observable<T> | Observable<T>[])[]): MonoTypeOperatorFunction<T> {\n  return function raceOperatorFunction(source: Observable<T>) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray(observables[0])) {\n      observables = observables[0] as Observable<T>[];\n    }\n\n    return source.lift.call(raceStatic(source, ...(observables as Observable<T>[])));\n  };\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { empty } from '../observable/empty';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Similar to {@link retry}, this operator repeats the stream of items emitted by the source for non error cases.\n * Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.\n *\n * Note: `repeat(0)` returns an empty observable and `repeat()` will repeat forever\n *\n * ## Example\n * Repeat a message stream\n * ```ts\n * import { of } from 'rxjs';\n * import { repeat, delay } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const example = source.pipe(repeat(3));\n * example.subscribe(x => console.log(x));\n *\n * // Results\n * // Repeat message\n * // Repeat message\n * // Repeat message\n * ```\n *\n * Repeat 3 values, 2 times\n * ```ts\n * import { interval } from 'rxjs';\n * import { repeat, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(take(3), repeat(2));\n * example.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that will resubscribe to the source stream when the source stream completes\n * , at most count times.\n * @method repeat\n * @owner Observable\n */\nexport function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else if (count < 0) {\n      return source.lift(new RepeatOperator(-1, source));\n    } else {\n      return source.lift(new RepeatOperator(count - 1, source));\n    }\n  };\n}\n\nclass RepeatOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatSubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  complete() {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.complete();\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n * Repeat a message stream on click\n * ```ts\n * import { of, fromEvent } from 'rxjs';\n * import { repeatWhen } from 'rxjs/operators';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * source.pipe(repeatWhen(() => documentClick$)\n * ).subscribe(data => console.log(data))\n * ```\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RepeatWhenOperator(notifier));\n}\n\nclass RepeatWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (notifications: Observable<any>) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatWhenSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private notifications?: Subject<any>;\n  private retries?: Observable<any>;\n  private retriesSubscription?: Subscription;\n  private sourceIsBeingSubscribedTo: boolean = true;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (notifications: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  notifyNext(): void {\n    this.sourceIsBeingSubscribedTo = true;\n    this.source.subscribe(this);\n  }\n\n  notifyComplete(): void {\n    if (this.sourceIsBeingSubscribedTo === false) {\n      return super.complete();\n    }\n  }\n\n  complete() {\n    this.sourceIsBeingSubscribedTo = false;\n\n    if (!this.isStopped) {\n      if (!this.retries) {\n        this.subscribeToRetries();\n      }\n      if (!this.retriesSubscription || this.retriesSubscription.closed) {\n        return super.complete();\n      }\n\n      this._unsubscribeAndRecycle();\n      this.notifications!.next(undefined);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { notifications, retriesSubscription } = this;\n    if (notifications) {\n      notifications.unsubscribe();\n      this.notifications = undefined;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = undefined;\n    }\n    this.retries = undefined;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null!;\n    super._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    return this;\n  }\n\n  private subscribeToRetries() {\n    this.notifications = new Subject();\n    let retries;\n    try {\n      const { notifier } = this;\n      retries = notifier(this.notifications);\n    } catch (e) {\n      return super.complete();\n    }\n    this.retries = retries;\n    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n *\n * ## Example\n * ```ts\n * import { interval, of, throwError } from 'rxjs';\n * import { mergeMap, retry } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   mergeMap(val => {\n *     if(val > 5){\n *       return throwError('Error!');\n *     }\n *     return of(val);\n *   }),\n *   //retry 2 times on error\n *   retry(2)\n * );\n *\n * const subscribe = example.subscribe({\n *   next: val => console.log(val),\n *   error: val => console.log(`${val}: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // \"Error!: Retried 2 times then quit!\"\n * ```\n *\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nexport function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));\n}\n\nclass RetryOperator<T> implements Operator<T, T> {\n  constructor(private count: number,\n              private source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetrySubscriber<T> extends Subscriber<T> {\n  constructor(destination: Subscriber<any>,\n              private count: number,\n              private source: Observable<T>) {\n    super(destination);\n  }\n  error(err: any) {\n    if (!this.isStopped) {\n      const { source, count } = this;\n      if (count === 0) {\n        return super.error(err);\n      } else if (count > -1) {\n        this.count = count - 1;\n      }\n      source.subscribe(this._unsubscribeAndRecycle());\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new RetryWhenOperator(notifier, source));\n}\n\nclass RetryWhenOperator<T> implements Operator<T, T> {\n  constructor(protected notifier: (errors: Observable<any>) => Observable<any>,\n              protected source: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RetryWhenSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private errors?: Subject<any>;\n  private retries?: Observable<any>;\n  private retriesSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private notifier: (errors: Observable<any>) => Observable<any>,\n              private source: Observable<T>) {\n    super(destination);\n  }\n\n  error(err: any) {\n    if (!this.isStopped) {\n\n      let errors = this.errors;\n      let retries: any = this.retries;\n      let retriesSubscription = this.retriesSubscription;\n\n      if (!retries) {\n        errors = new Subject();\n        try {\n          const { notifier } = this;\n          retries = notifier(errors);\n        } catch (e) {\n          return super.error(e);\n        }\n        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));\n      } else {\n        this.errors = undefined;\n        this.retriesSubscription = undefined;\n      }\n\n      this._unsubscribeAndRecycle();\n\n      this.errors = errors;\n      this.retries = retries;\n      this.retriesSubscription = retriesSubscription;\n\n      errors!.next(err);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { errors, retriesSubscription } = this;\n    if (errors) {\n      errors.unsubscribe();\n      this.errors = undefined;\n    }\n    if (retriesSubscription) {\n      retriesSubscription.unsubscribe();\n      this.retriesSubscription = undefined;\n    }\n    this.retries = undefined;\n  }\n\n  notifyNext(): void {\n    const { _unsubscribe } = this;\n\n    this._unsubscribe = null!;\n    this._unsubscribeAndRecycle();\n    this._unsubscribe = _unsubscribe;\n\n    this.source.subscribe(this);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n * On every click, sample the most recent \"seconds\" timer\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { sample } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleOperator(notifier));\n}\n\nclass SampleOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const sampleSubscriber = new SampleSubscriber(subscriber);\n    const subscription = source.subscribe(sampleSubscriber);\n    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private value?: T;\n  private hasValue: boolean = false;\n\n  protected _next(value: T) {\n    this.value = value;\n    this.hasValue = true;\n  }\n\n  notifyNext(): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next!(this.value!);\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n * Every second, emit the most recent click at most once\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { sampleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));\n}\n\nclass SampleTimeOperator<T> implements Operator<T, T> {\n  constructor(private period: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleTimeSubscriber<T> extends Subscriber<T> {\n  lastValue: T;\n  hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private period: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n  }\n\n  protected _next(value: T) {\n    this.lastValue = value;\n    this.hasValue = true;\n  }\n\n  notifyNext() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  }\n}\n\nfunction dispatchNotification<T>(this: SchedulerAction<any>, state: any) {\n  let { subscriber, period } = state;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { Observer, OperatorFunction } from '../types';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * ## Example\n * figure out if the Konami code matches\n * ```ts\n * import { from, fromEvent } from 'rxjs';\n * import { sequenceEqual, bufferCount, mergeMap, map } from 'rxjs/operators';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(\n *     last11 => from(last11).pipe(sequenceEqual(codes)),\n *   ),\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparator] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport function sequenceEqual<T>(compareTo: Observable<T>,\n                                 comparator?: (a: T, b: T) => boolean): OperatorFunction<T, boolean> {\n  return (source: Observable<T>) => source.lift(new SequenceEqualOperator(compareTo, comparator));\n}\n\nexport class SequenceEqualOperator<T> implements Operator<T, boolean> {\n  constructor(private compareTo: Observable<T>,\n              private comparator: (a: T, b: T) => boolean) {\n  }\n\n  call(subscriber: Subscriber<boolean>, source: any): any {\n    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SequenceEqualSubscriber<T, R> extends Subscriber<T> {\n  private _a: T[] = [];\n  private _b: T[] = [];\n  private _oneComplete = false;\n\n  constructor(destination: Observer<R>,\n              private compareTo: Observable<T>,\n              private comparator: (a: T, b: T) => boolean) {\n    super(destination);\n    (this.destination as Subscription).add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n  }\n\n  protected _next(value: T): void {\n    if (this._oneComplete && this._b.length === 0) {\n      this.emit(false);\n    } else {\n      this._a.push(value);\n      this.checkValues();\n    }\n  }\n\n  public _complete(): void {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n    this.unsubscribe();\n  }\n\n  checkValues() {\n    const { _a, _b, comparator } = this;\n    while (_a.length > 0 && _b.length > 0) {\n      let a = _a.shift();\n      let b = _b.shift();\n      let areEqual = false;\n      try {\n        areEqual = comparator ? comparator(a, b) : a === b;\n      } catch (e) {\n        this.destination.error(e);\n      }\n      if (!areEqual) {\n        this.emit(false);\n      }\n    }\n  }\n\n  emit(value: boolean) {\n    const { destination } = this;\n    destination.next(value);\n    destination.complete();\n  }\n\n  nextB(value: T) {\n    if (this._oneComplete && this._a.length === 0) {\n      this.emit(false);\n    } else {\n      this._b.push(value);\n      this.checkValues();\n    }\n  }\n\n  completeB() {\n    if (this._oneComplete) {\n      this.emit(this._a.length === 0 && this._b.length === 0);\n    } else {\n      this._oneComplete = true;\n    }\n  }\n}\n\nclass SequenceEqualCompareToSubscriber<T, R> extends Subscriber<T> {\n  constructor(destination: Observer<R>, private parent: SequenceEqualSubscriber<T, R>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.parent.nextB(value);\n  }\n\n  protected _error(err: any): void {\n    this.parent.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.completeB();\n    this.unsubscribe();\n  }\n}\n","import { Observable } from '../Observable';\nimport { multicast } from './multicast';\nimport { refCount } from './refCount';\nimport { Subject } from '../Subject';\n\nimport { MonoTypeOperatorFunction } from '../types';\n\nfunction shareSubjectFactory() {\n  return new Subject();\n}\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * ![](share.png)\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport function share<T>(): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => refCount()(multicast(shareSubjectFactory)(source)) as Observable<T>;\n}\n","import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplayed observable` forever,\n * but an errored source can be retried.\n *\n * ## Why use shareReplay?\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ![](shareReplay.png)\n *\n * ## Example\n * ```ts\n * import { interval } from 'rxjs';\n * import { shareReplay, take } from 'rxjs/operators';\n *\n * const obs$ = interval(1000);\n * const shared$ = obs$.pipe(\n *   take(4),\n *   shareReplay(3)\n * );\n * shared$.subscribe(x => console.log('source A: ', x));\n * shared$.subscribe(y => console.log('source B: ', y));\n *\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param {Number} [bufferSize=Number.POSITIVE_INFINITY] Maximum element count of the replay buffer.\n * @param {Number} [windowTime=Number.POSITIVE_INFINITY] Maximum time length of the replay buffer in milliseconds.\n * @param {Scheduler} [scheduler] Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return {Observable} An observable sequence that contains the elements of a sequence produced\n * by multicasting the source sequence within a selector function.\n * @method shareReplay\n * @owner Observable\n */\nexport function shareReplay<T>(\n  config: ShareReplayConfig\n): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let config: ShareReplayConfig;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    config = configOrBufferSize as ShareReplayConfig;\n  } else {\n    config = {\n      bufferSize: configOrBufferSize as number | undefined,\n      windowTime,\n      refCount: false,\n      scheduler,\n    };\n  }\n  return (source: Observable<T>) => source.lift(shareReplayOperator(config));\n}\n\nfunction shareReplayOperator<T>({\n  bufferSize = Number.POSITIVE_INFINITY,\n  windowTime = Number.POSITIVE_INFINITY,\n  refCount: useRefCount,\n  scheduler,\n}: ShareReplayConfig) {\n  let subject: ReplaySubject<T> | undefined;\n  let refCount = 0;\n  let subscription: Subscription | undefined;\n  let hasError = false;\n  let isComplete = false;\n\n  return function shareReplayOperation(\n    this: Subscriber<T>,\n    source: Observable<T>\n  ) {\n    refCount++;\n    let innerSub: Subscription;\n    if (!subject || hasError) {\n      hasError = false;\n      subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);\n      innerSub = subject.subscribe(this);\n      subscription = source.subscribe({\n        next(value) {\n          subject.next(value);\n        },\n        error(err) {\n          hasError = true;\n          subject.error(err);\n        },\n        complete() {\n          isComplete = true;\n          subscription = undefined;\n          subject.complete();\n        },\n      });\n\n      // Here we need to check to see if the source synchronously completed. Although\n      // we're setting `subscription = undefined` in the completion handler, if the source\n      // is synchronous, that will happen *before* subscription is set by the return of\n      // the `subscribe` call.\n      if (isComplete) {\n        subscription = undefined;\n      }\n    } else {\n      innerSub = subject.subscribe(this);\n    }\n\n    this.add(() => {\n      refCount--;\n      innerSub.unsubscribe();\n      innerSub = undefined;\n      if (subscription && !isComplete && useRefCount && refCount === 0) {\n        subscription.unsubscribe();\n        subscription = undefined;\n        subject = undefined;\n      }\n    });\n  };\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { Observer, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable\n * emits items but none match the specified predicate then `undefined` is emitted.\n *\n * <span class=\"informal\">Like {@link first}, but emit with error notification if there is more than one value.</span>\n * ![](single.png)\n *\n * ## Example\n * emits 'error'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single());\n * numbers.subscribe(x => console.log('never get called'), e => console.log('error'));\n * // result\n * // 'error'\n * ```\n *\n * emits 'undefined'\n * ```ts\n * import { range } from 'rxjs';\n * import { single } from 'rxjs/operators';\n *\n * const numbers = range(1,5).pipe(single(x => x === 10));\n * numbers.subscribe(x => console.log(x));\n * // result\n * // 'undefined'\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate or `undefined` when no items match.\n *\n * @method single\n * @owner Observable\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source));\n}\n\nclass SingleOperator<T> implements Operator<T, T> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SingleSubscriber<T> extends Subscriber<T> {\n  private seenValue: boolean = false;\n  private singleValue: T;\n  private index: number = 0;\n\n  constructor(destination: Observer<T>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  private applySingleValue(value: T): void {\n    if (this.seenValue) {\n      this.destination.error('Sequence contains more than one element');\n    } else {\n      this.seenValue = true;\n      this.singleValue = value;\n    }\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n\n    if (this.predicate) {\n      this.tryNext(value, index);\n    } else {\n      this.applySingleValue(value);\n    }\n  }\n\n  private tryNext(value: T, index: number): void {\n    try {\n      if (this.predicate(value, index, this.source)) {\n        this.applySingleValue(value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n\n    if (this.index > 0) {\n      destination.next(this.seenValue ? this.singleValue : undefined);\n      destination.complete();\n    } else {\n      destination.error(new EmptyError);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipOperator(count));\n}\n\nclass SkipOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipSubscriber<T> extends Subscriber<T> {\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(x: T) {\n    if (++this.count > this.total) {\n      this.destination.next(x);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * ![](skipLast.png)\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * ## Example\n * Skip the last 2 values of an Observable with many values\n * ```ts\n * import { range } from 'rxjs';\n * import { skipLast } from 'rxjs/operators';\n *\n * const many = range(1, 5);\n * const skipLastTwo = many.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic, ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable emits the first value.\n * This can be particularly useful in combination with user interactions, responses of http requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally the `skipUntil` operator subscribes to the passed in observable (in the following called *notifier*) in order to recognize the emission\n * of its first value. When this happens, the operator unsubscribes from the *notifier* and starts emitting the values of the *source*\n * observable. It will never let the *source* observable emit any values if the *notifier* completes or throws an error without emitting\n * a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere within the page.\n *\n * ```ts\n * import { interval, fromEvent } from 'rxjs';\n * import { skipUntil } from 'rxjs/operators';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * const subscribe = emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier));\n}\n\nclass SkipUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(destination: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipUntilSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private hasValue: boolean = false;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>, notifier: ObservableInput<any>) {\n    super(destination);\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    this.add(innerSubscriber);\n    this.innerSubscription = innerSubscriber;\n    const innerSubscription = innerSubscribe(notifier, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      this.add(innerSubscription);\n      this.innerSubscription = innerSubscription;\n    }\n  }\n\n  protected _next(value: T) {\n    if (this.hasValue) {\n      super._next(value);\n    }\n  }\n\n  notifyNext(): void {\n    this.hasValue = true;\n    if (this.innerSubscription) {\n      this.innerSubscription.unsubscribe();\n    }\n  }\n\n  notifyComplete() {\n    /* do nothing */\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipWhileOperator(predicate));\n}\n\nclass SkipWhileOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipWhileSubscriber<T> extends Subscriber<T> {\n  private skipping: boolean = true;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    if (this.skipping) {\n      this.tryCallPredicate(value);\n    }\n\n    if (!this.skipping) {\n      destination.next(value);\n    }\n  }\n\n  private tryCallPredicate(value: T): void {\n    try {\n      const result = this.predicate(value, this.index++);\n      this.skipping = Boolean(result);\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { isScheduler } from '../util/isScheduler';\nimport { MonoTypeOperatorFunction, OperatorFunction, SchedulerLike } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D>(v1: D, scheduler: SchedulerLike): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E>(v1: D, v2: E, scheduler: SchedulerLike): OperatorFunction<T, T | D | E>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F>(v1: D, v2: E, v3: F, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G>(v1: D, v2:  E, v3: F, v4: G, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I, scheduler: SchedulerLike): OperatorFunction<T, T | D | E | F | G | H | I>;\n\nexport function startWith<T, D>(v1: D): OperatorFunction<T, T | D>;\nexport function startWith<T, D, E>(v1: D, v2: E): OperatorFunction<T, T | D | E>;\nexport function startWith<T, D, E, F>(v1: D, v2: E, v3: F): OperatorFunction<T, T | D | E | F>;\nexport function startWith<T, D, E, F, G>(v1: D, v2:  E, v3: F, v4: G): OperatorFunction<T, T | D | E | F | G>;\nexport function startWith<T, D, E, F, G, H>(v1: D, v2: E, v3: F, v4: G, v5: H): OperatorFunction<T, T | D | E | F | G | H>;\nexport function startWith<T, D, E, F, G, H, I>(v1: D, v2: E, v3: F, v4: G, v5: H, v6: I): OperatorFunction<T, T | D | E | F | G | H | I>;\nexport function startWith<T, D = T>(...array: D[]): OperatorFunction<T, T | D>;\n/** @deprecated use {@link scheduled} and {@link concatAll} (e.g. `scheduled([[a, b, c], source], scheduler).pipe(concatAll())`) */\nexport function startWith<T, D = T>(...array: Array<D | SchedulerLike>): OperatorFunction<T, T | D>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Start the chain of emissions with `\"first\"`, `\"second\"`\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { startWith } from 'rxjs/operators';\n *\n * of(\"from source\")\n *   .pipe(startWith(\"first\", \"second\"))\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * //   \"first\"\n * //   \"second\"\n * //   \"from source\"\n * ```\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {SchedulerLike} [scheduler] - A {@link SchedulerLike} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nexport function startWith<T, D>(...array: Array<T | SchedulerLike>): OperatorFunction<T, T | D> {\n  const scheduler = array[array.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    // deprecated path\n    array.pop();\n    return (source: Observable<T>) => concat(array as T[], source, scheduler);\n  } else {\n    return (source: Observable<T>) => concat(array as T[], source);\n  }\n}\n","import { SchedulerLike, SchedulerAction } from '../types';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { asap } from '../scheduler/asap';\nimport { isNumeric } from '../util/isNumeric';\n\nexport interface DispatchArg<T> {\n  source: Observable<T>;\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class SubscribeOnObservable<T> extends Observable<T> {\n  /** @nocollapse */\n  static create<T>(source: Observable<T>, delay: number = 0, scheduler: SchedulerLike = asap): Observable<T> {\n    return new SubscribeOnObservable(source, delay, scheduler);\n  }\n\n  /** @nocollapse */\n  static dispatch<T>(this: SchedulerAction<T>, arg: DispatchArg<T>): Subscription {\n    const { source, subscriber } = arg;\n    return this.add(source.subscribe(subscriber));\n  }\n\n  constructor(public source: Observable<T>,\n              private delayTime: number = 0,\n              private scheduler: SchedulerLike = asap) {\n    super();\n    if (!isNumeric(delayTime) || delayTime < 0) {\n      this.delayTime = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n      this.scheduler = asap;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    const delay = this.delayTime;\n    const source = this.source;\n    const scheduler = this.scheduler;\n\n    return scheduler.schedule<DispatchArg<any>>(SubscribeOnObservable.dispatch, delay, {\n      source, subscriber\n    });\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { SubscribeOnObservable } from '../observable/SubscribeOnObservable';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n * Given the following code:\n * ```javascript\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3, 4);\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n * This will result in the output of `1 2 3 4 5 6 7 8 9`.\n *\n * But if we instead us the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emited by Observable `a`:\n * ```javascript\n * import { of, merge, asyncScheduler } from 'rxjs';\n * import { subscribeOn } from 'rxjs/operators';\n *\n * const a = of(1, 2, 3, 4).pipe(subscribeOn(asyncScheduler));\n * const b = of(5, 6, 7, 8, 9);\n * merge(a, b).subscribe(console.log);\n * ```\n *\n * The output will instead be `5 6 7 8 9 1 2 3 4`.\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param {SchedulerLike} scheduler - The {@link SchedulerLike} to perform subscription actions on.\n * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified {@link SchedulerLike}.\n .\n * @method subscribeOn\n * @owner Observable\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function subscribeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new SubscribeOnOperator<T>(scheduler, delay));\n  };\n}\n\nclass SubscribeOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike,\n              private delay: number) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return new SubscribeOnObservable<T>(\n      source, this.delay, this.scheduler\n    ).subscribe(subscriber);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n * Generate new Observable according to source Observable values\n * ```typescript\n * import { of } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const switched = of(1, 2, 3).pipe(switchMap((x: number) => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // ... and so on\n * ```\n *\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap((ev) => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return (source: Observable<T>) => source.pipe(\n      switchMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii))\n      ))\n    );\n  }\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n\nclass SwitchMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index = 0;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error!(error);\n      return;\n    }\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    this.innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (this.innerSubscription !== innerSubscriber) {\n      destination.add(this.innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n    this.unsubscribe();\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = undefined;\n  }\n\n  notifyComplete(): void {\n    this.innerSubscription = undefined;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(innerValue: R): void {\n      this.destination.next!(innerValue);\n  }\n}\n","import {OperatorFunction, ObservableInput} from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\nexport function switchAll<T>(): OperatorFunction<ObservableInput<T>, T>;\nexport function switchAll<R>(): OperatorFunction<any, R>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one.\n *\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchAll, map, tap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map((ev) => interval(1000)));\n *\n * source.pipe(\n *   switchAll()\n * ).subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...\n * // click\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n */\n\nexport function switchAll<T>(): OperatorFunction<ObservableInput<T>, T> {\n  return switchMap(identity);\n}\n","import { ObservableInput, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<R>(observable: ObservableInput<R>): OperatorFunction<any, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport function switchMapTo<T, R>(observable: ObservableInput<R>, resultSelector: undefined): OperatorFunction<T, R>;\n/** @deprecated resultSelector is no longer supported. Switch to using switchMap with an inner map */\nexport function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMapTo } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through the deprecated `resultSelector`)\n * every time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(\n  innerObservable: ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, I|R> {\n  return resultSelector ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { innerSubscribe, SimpleInnerSubscriber, SimpleOuterSubscriber } from '../innerSubscribe';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { takeUntil } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n    const notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));\n    if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n      takeUntilSubscriber.add(notifierSubscription);\n      return source.subscribe(takeUntilSubscriber);\n    }\n    return takeUntilSubscriber;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  seenValue = false;\n\n  constructor(destination: Subscriber<any>, ) {\n    super(destination);\n  }\n\n  notifyNext(): void {\n    this.seenValue = true;\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n * Emit click events only while the clientX property is greater than 200\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { takeWhile } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @param {boolean} inclusive When set to `true` the value that caused\n * `predicate` to return `false` will also be emitted.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nexport function takeWhile<T>(\n    predicate: (value: T, index: number) => boolean,\n    inclusive = false): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) =>\n             source.lift(new TakeWhileOperator(predicate, inclusive));\n}\n\nclass TakeWhileOperator<T> implements Operator<T, T> {\n  constructor(\n      private predicate: (value: T, index: number) => boolean,\n      private inclusive: boolean) {}\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n        new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeWhileSubscriber<T> extends Subscriber<T> {\n  private index: number = 0;\n\n  constructor(\n      destination: Subscriber<T>,\n      private predicate: (value: T, index: number) => boolean,\n      private inclusive: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const destination = this.destination;\n    let result: boolean;\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n    this.nextOrComplete(value, result);\n  }\n\n  private nextOrComplete(value: T, predicateResult: boolean): void {\n    const destination = this.destination;\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n      destination.complete();\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { tap, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\nexport interface ThrottleConfig {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport const defaultThrottleConfig: ThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.png)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttle } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>,\n                            config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));\n}\n\nclass ThrottleOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private _throttled?: Subscription;\n  private _sendValue?: T;\n  private _hasValue = false;\n\n  constructor(protected destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private _leading: boolean,\n              private _trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this._hasValue = true;\n    this._sendValue = value;\n\n    if (!this._throttled) {\n      if (this._leading) {\n        this.send();\n      } else {\n        this.throttle(value);\n      }\n    }\n  }\n\n  private send() {\n    const { _hasValue, _sendValue } = this;\n    if (_hasValue) {\n      this.destination.next(_sendValue);\n      this.throttle(_sendValue!);\n    }\n    this._hasValue = false;\n    this._sendValue = undefined;\n  }\n\n  private throttle(value: T): void {\n    const duration = this.tryDurationSelector(value);\n    if (!!duration) {\n      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));\n    }\n  }\n\n  private tryDurationSelector(value: T): SubscribableOrPromise<any> | null {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  }\n\n  private throttlingDone() {\n    const { _throttled, _trailing } = this;\n    if (_throttled) {\n      _throttled.unsubscribe();\n    }\n    this._throttled = undefined;\n\n    if (_trailing) {\n      this.send();\n    }\n  }\n\n  notifyNext(): void {\n    this.throttlingDone();\n  }\n\n  notifyComplete(): void {\n    this.throttlingDone();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * #### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { throttleTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * #### Double Click\n *\n * The following example only emits clicks which happen within a subsequent\n * delay of 400ms of the previous click. This for example can emulate a double\n * click. It makes use of the `trailing` parameter of the throttle configuration.\n *\n * ```ts\n * import { fromEvent, asyncScheduler } from 'rxjs';\n * import { throttleTime, withLatestFrom } from 'rxjs/operators';\n *\n * // defaultThottleConfig = { leading: true, trailing: false }\n * const throttleConfig = {\n *   leading: false,\n *   trailing: true\n * }\n *\n * const click = fromEvent(document, 'click');\n * const doubleClick = click.pipe(\n *   throttleTime(400, asyncScheduler, throttleConfig)\n * );\n *\n * doubleClick.subscribe((throttleValue: Event) => {\n *   console.log(`Double-clicked! Timestamp: ${throttleValue.timeStamp}`);\n * });\n * ```\n *\n * If you enable the `leading` parameter in this example, the output would be the primary click and\n * the double click, but restricts additional clicks within 400ms.\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: SchedulerLike = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule<DispatchArg<T>>(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      } else if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    }\n  }\n\n  protected _complete() {\n    if (this._hasTrailingValue) {\n      this.destination.next(this._trailingValue);\n      this.destination.complete();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n","\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { scan } from './scan';\nimport { defer } from '../observable/defer';\nimport { map } from './map';\n\n/**\n *\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeinterval.png)\n *\n * ## Examples\n * Emit inteval between current value with the last value\n *\n * ```ts\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeInterval())\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value),\n *     err => console.log(err),\n * );\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // {value: 0, interval: 1000}\n * // {value: 1, interval: 1000}\n * // {value: 2, interval: 1000}\n * ```\n *\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\n * @return {Observable<{ interval: number, value: T }>} Observable that emit infomation about value and interval\n * @method timeInterval\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = async): OperatorFunction<T, TimeInterval<T>> {\n  return (source: Observable<T>) => defer(() => {\n    return source.pipe(\n      // TODO(benlesh): correct these typings.\n      scan(\n        ({ current }, value) => ({ value, current: scheduler.now(), last: current }),\n        { current: scheduler.now(), value: undefined,  last: undefined }\n      ) as any,\n      map<any, TimeInterval<T>>(({ current, last, value }) => new TimeInterval(value, current - last)),\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\n/**\n * @deprecated exposed API, use as interface only.\n */\nexport class TimeInterval<T> {\n  constructor(public value: T, public interval: number) {}\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * ![](timeoutWith.png)\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * ## Example\n * Add fallback observable\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeoutWith } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n * const minutes = interval(60 * 1000);\n *\n * seconds.pipe(timeoutWith(900, minutes))\n *   .subscribe(\n *     value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                  // since first value of `seconds` will not arrive fast enough.\n *     err => console.log(err),     // Would be called after 900ms in case of `timeout`,\n *                                  // but here will never be called.\n *   );\n * ```\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith<T, R>(due: number | Date,\n                                  withObservable: ObservableInput<R>,\n                                  scheduler: SchedulerLike = async): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => {\n    let absoluteTimeout = isDate(due);\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nclass TimeoutWithOperator<T> implements Operator<T, T> {\n  constructor(private waitFor: number,\n              private absoluteTimeout: boolean,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TimeoutWithSubscriber(\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n\n  private action?: SchedulerAction<TimeoutWithSubscriber<T, R>>;\n\n  constructor(destination: Subscriber<T>,\n              private absoluteTimeout: boolean,\n              private waitFor: number,\n              private withObservable: ObservableInput<any>,\n              private scheduler: SchedulerLike) {\n    super(destination);\n    this.scheduleTimeout();\n  }\n\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\n    const { withObservable } = subscriber;\n    subscriber._unsubscribeAndRecycle();\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  }\n\n  private scheduleTimeout(): void {\n    const { action } = this;\n    if (action) {\n      // Recycle the action if we've already scheduled one. All the production\n      // Scheduler Actions mutate their state/delay time and return themeselves.\n      // VirtualActions are immutable, so they create and return a clone. In this\n      // case, we need to set the action reference to the most recent VirtualAction,\n      // to ensure that's the one we clone from next time.\n      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\n    } else {\n      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(\n        TimeoutWithSubscriber.dispatchTimeout as any, this.waitFor, this\n      )));\n    }\n  }\n\n  protected _next(value: T): void {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n    super._next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.action = undefined;\n    this.scheduler = null!;\n    this.withObservable = null!;\n  }\n}\n","import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\nimport { timeoutWith } from './timeoutWith';\nimport { throwError } from '../observable/throwError';\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * ## Examples\n * Check if ticks are emitted within certain timespan\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(timeout(1100))      // Let's use bigger timespan to be safe,\n *                                  // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err),     // Will never be called.\n * );\n *\n * seconds.pipe(timeout(900))\n * .subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err),     // Will emit error before even first value is emitted,\n *                                  // since it did not arrive within 900ms period.\n * );\n * ```\n *\n * Use Date to check if Observable completed\n * ```ts\n * import { interval } from 'rxjs';\n * import { timeout } from 'rxjs/operators';\n *\n * const seconds = interval(1000);\n *\n * seconds.pipe(\n *   timeout(new Date(\"December 17, 2020 03:24:00\")),\n * )\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err)      // On December 17, 2020 at 03:24:00 it will emit an error,\n *                                  // since Observable did not complete by then.\n * );\n * ```\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nexport function timeout<T>(due: number | Date,\n                           scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n","\nimport { async } from '../scheduler/async';\nimport { OperatorFunction, SchedulerLike, Timestamp as TimestampInterface } from '../types';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default it uses the *async* scheduler which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the documents click event.\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { timestamp } from 'rxjs/operators';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type {value: MouseEvent, timestamp: number}\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nexport function timestamp<T>(scheduler: SchedulerLike = async): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => new Timestamp(value, scheduler.now()));\n  // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\n\nexport class Timestamp<T> implements TimestampInterface<T> {\n  constructor(public value: T, public timestamp: number) {\n  }\n}\n","import { reduce } from './reduce';\nimport { OperatorFunction } from '../types';\n\nfunction toArrayReducer<T>(arr: T[], item: T, index: number) {\n  if (index === 0) {\n    return [item];\n  }\n  arr.push(item);\n  return arr;\n}\n\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n *  ## Example\n * ```ts\n * import { interval } from 'rxjs';\n * import { toArray, take } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n *\n * ```\n* @return An array from an observable sequence.\n* @method toArray\n* @owner Observable\n*/\nexport function toArray<T>(): OperatorFunction<T, T[]> {\n  return reduce(toArrayReducer, [] as T[]);\n}\n","import { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscriber } from '../Subscriber';\nimport { Operator } from '../Operator';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * ## Example\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { window, mergeAll, map, take } from 'rxjs/operators';\n *\n *  const clicks = fromEvent(document, 'click');\n *  const sec = interval(1000);\n *  const result = clicks.pipe(\n *      window(sec),\n *      map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *      mergeAll(),              // flatten the Observable-of-Observables\n *  );\n *  result.subscribe(x => console.log(x));\n * ```\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nexport function window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator(windowBoundaries));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowBoundaries: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    const windowSubscriber = new WindowSubscriber(subscriber);\n    const sourceSubscription = source.subscribe(windowSubscriber);\n    if (!sourceSubscription.closed) {\n      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));\n    }\n    return sourceSubscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends SimpleOuterSubscriber<T, any> {\n\n  private window: Subject<T> = new Subject<T>();\n\n  constructor(destination: Subscriber<Observable<T>>) {\n    super(destination);\n    destination.next(this.window);\n  }\n\n  notifyNext(): void {\n    this.openWindow();\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  notifyComplete(): void {\n    this._complete();\n  }\n\n  protected _next(value: T): void {\n    this.window.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window.error(err);\n    this.destination.error!(err);\n  }\n\n  protected _complete(): void {\n    this.window.complete();\n    this.destination.complete!();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    this.window = null!;\n  }\n\n  private openWindow(): void  {\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n    const destination = this.destination;\n    const newWindow = this.window = new Subject<T>();\n    destination.next!(newWindow);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n * Ignore every 3rd click event, starting from the first one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, map, mergeAll, skip } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowCount, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll(),              // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  protected _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction, SchedulerLike, SchedulerAction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n * In every window of 1 second each, emit at most 2 click events\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\n *   mergeAll(),                    // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with maxWindowCount instead of take\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { windowTime, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\n *   mergeAll(),                // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(windowTimeSpan: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\n\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\n  let scheduler: SchedulerLike = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n\n  return function windowTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: SchedulerLike;\n}\n\ninterface TimeSpanOnlyState<T> {\n    window: CountedSubject<T>;\n    windowTimeSpan: number;\n    subscriber: WindowTimeSubscriber<T>;\n  }\n\ninterface CloseWindowContext<T> {\n  action: SchedulerAction<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface CloseState<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: CountedSubject<T>;\n  context: CloseWindowContext<T>;\n}\n\nclass CountedSubject<T> extends Subject<T> {\n  private _numberOfNextedValues: number = 0;\n\n  next(value?: T): void {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues(): number {\n    return this._numberOfNextedValues;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: CountedSubject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number | null,\n              private maxWindowSize: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n\n    const window = this.openWindow();\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule<CreationState<T>>(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule<TimeSpanOnlyState<T>>(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T): void {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  protected _error(err: any): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete(): void {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  public openWindow(): CountedSubject<T> {\n    const window = new CountedSubject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  public closeWindow(window: CountedSubject<T>): void {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: SchedulerAction<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation<T>(this: SchedulerAction<CreationState<T>>, state: CreationState<T>): void {\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\n  const { subscriber, window, context } = state;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n * Every other second, emit the click events from the next 500ms\n * ```ts\n * import { fromEvent, interval, EMPTY } from 'rxjs';\n * import { windowToggle, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n      let closingNotifier;\n      try {\n        const { closingSelector } = this;\n        closingNotifier = closingSelector(innerValue);\n      } catch (e) {\n        return this.error(e);\n      }\n\n      const window = new Subject<T>();\n      const subscription = new Subscription();\n      const context = { window, subscription };\n      this.contexts.push(context);\n      const innerSubscription = subscribeToResult(this, closingNotifier, context as any);\n\n      if (innerSubscription.closed) {\n        this.closeWindow(this.contexts.length - 1);\n      } else {\n        (<any>innerSubscription).context = context;\n        subscription.add(innerSubscription);\n      }\n\n      this.destination.next(window);\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../types';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n * Emit only the first two clicks events in every window of [1-5] random seconds\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { windowWhen, map, mergeAll, take } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions\n *   mergeAll()                         // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nexport function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return function windowWhenOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowOperator<T>(closingSelector));\n  };\n}\n\nclass WindowOperator<T> implements Operator<T, Observable<T>> {\n  constructor(private closingSelector: () => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowSubscriber<T> extends OuterSubscriber<T, any> {\n  private window?: Subject<T>;\n  private closingNotification?: Subscription;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private closingSelector: () => Observable<any>) {\n    super(destination);\n    this.openWindow();\n  }\n\n  notifyNext(_outerValue: T, _innerValue: any,\n             _outerIndex: number, _innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  notifyError(error: any): void {\n    this._error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, any>): void {\n    this.openWindow(innerSub);\n  }\n\n  protected _next(value: T): void {\n    this.window!.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.window!.error(err);\n    this.destination.error(err);\n    this.unsubscribeClosingNotification();\n  }\n\n  protected _complete(): void {\n    this.window!.complete();\n    this.destination.complete();\n    this.unsubscribeClosingNotification();\n  }\n\n  private unsubscribeClosingNotification(): void {\n    if (this.closingNotification) {\n      this.closingNotification.unsubscribe();\n    }\n  }\n\n  private openWindow(innerSub: InnerSubscriber<T, any> | null = null): void {\n    if (innerSub) {\n      this.remove(innerSub);\n      innerSub.unsubscribe();\n    }\n\n    const prevWindow = this.window;\n    if (prevWindow) {\n      prevWindow.complete();\n    }\n\n    const window = this.window = new Subject<T>();\n    this.destination.next(window);\n\n    let closingNotifier;\n    try {\n      const { closingSelector } = this;\n      closingNotifier = closingSelector();\n    } catch (e) {\n      this.destination.error(e);\n      this.window.error(e);\n      return;\n    }\n    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function withLatestFrom<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, R>(source2: O2, project: (v1: T, v2: ObservedValueOf<O2>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, R>(v2: O2, v3: O3, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>, R>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6, project: (v1: T, v2: ObservedValueOf<O2>, v3: ObservedValueOf<O3>, v4: ObservedValueOf<O4>, v5: ObservedValueOf<O5>, v6: ObservedValueOf<O6>) => R): OperatorFunction<T, R>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>>(source2: O2): OperatorFunction<T, [T, ObservedValueOf<O2>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>>(v2: O2, v3: O3): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>]>;\nexport function withLatestFrom<T, O2 extends ObservableInput<any>, O3 extends ObservableInput<any>, O4 extends ObservableInput<any>, O5 extends ObservableInput<any>, O6 extends ObservableInput<any>>(v2: O2, v3: O3, v4: O4, v5: O5, v6: O6): OperatorFunction<T, [T, ObservedValueOf<O2>, ObservedValueOf<O3>, ObservedValueOf<O4>, ObservedValueOf<O5>, ObservedValueOf<O6>]>;\nexport function withLatestFrom<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, R>;\nexport function withLatestFrom<T, R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): OperatorFunction<T, R>;\n\n/* tslint:enable:max-line-length */\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n * On every click event, emit an array with the latest timer event plus the click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { withLatestFrom } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nexport function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    let project: any;\n    if (typeof args[args.length - 1] === 'function') {\n      project = args.pop();\n    }\n    const observables = <Observable<any>[]>args;\n    return source.lift(new WithLatestFromOperator(observables, project));\n  };\n}\n\nclass WithLatestFromOperator<T, R> implements Operator<T, R> {\n  constructor(private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WithLatestFromSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private values: any[];\n  private toRespond: number[] = [];\n\n  constructor(destination: Subscriber<R>,\n              private observables: Observable<any>[],\n              private project?: (...values: any[]) => Observable<R>) {\n    super(destination);\n    const len = observables.length;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.toRespond.push(i);\n    }\n\n    for (let i = 0; i < len; i++) {\n      let observable = observables[i];\n      this.add(subscribeToResult<T, R>(this, observable, undefined, i));\n    }\n  }\n\n  notifyNext(_outerValue: T, innerValue: R,\n             outerIndex: number): void {\n    this.values[outerIndex] = innerValue;\n    const toRespond = this.toRespond;\n    if (toRespond.length > 0) {\n      const found = toRespond.indexOf(outerIndex);\n      if (found !== -1) {\n        toRespond.splice(found, 1);\n      }\n    }\n  }\n\n  notifyComplete() {\n    // noop\n  }\n\n  protected _next(value: T) {\n    if (this.toRespond.length === 0) {\n      const args = [value, ...this.values];\n      if (this.project) {\n        this._tryProject(args);\n      } else {\n        this.destination.next!(args);\n      }\n    }\n  }\n\n  private _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project!.apply(this, args);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.destination.next!(result);\n  }\n}\n","import { zip as zipStatic } from '../observable/zip';\nimport { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\n/** @deprecated Deprecated in favor of static zip. */\nexport function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @deprecated Deprecated in favor of static {@link zip}.\n */\nexport function zip<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return function zipOperatorFunction(source: Observable<T>) {\n    return source.lift.call(zipStatic<R>(source, ...observables));\n  };\n}","import { ZipOperator } from '../observable/zip';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\n\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new ZipOperator(project));\n}\n","var setPrototypeOf = require(\"./setPrototypeOf.js\");\nvar isNativeReflectConstruct = require(\"./isNativeReflectConstruct.js\");\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n  return _construct.apply(null, arguments);\n}\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var getPrototypeOf = require(\"./getPrototypeOf.js\");\nvar setPrototypeOf = require(\"./setPrototypeOf.js\");\nvar isNativeFunction = require(\"./isNativeFunction.js\");\nvar construct = require(\"./construct.js\");\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _wrapNativeSuper(Class);\n}\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["audit","AuditOperator","subscriber","AuditSubscriber","_super","_this","durationSelector","tslib_1","this","value","hasValue","duration","err","innerSubscription","innerSubscribe","SimpleInnerSubscriber","_a","throttled","remove","undefined","scheduler","buffer","BufferOperator","closingNotifier","BufferSubscriber","_next","prototype","startBufferEvery","BufferCountOperator","bufferSize","BufferCountSubscriber","BufferSkipCountSubscriber","call","buffers","count","i","length","_complete","destination","bufferTime","bufferTimeSpan","arguments","async","isScheduler","bufferCreationInterval","maxBufferSize","BufferTimeOperator","Context","BufferTimeSubscriber","context","closeState","add","dispatchBufferClose","contexts","len","context_1","filledBufferContext","onBufferFull","closeAction","unsubscribe","timeSpanOnlyState","openContext","push","dispatchBufferTimeSpanOnly","state","prevContext","dispatchBufferCreation","schedule","action","bufferToggle","BufferToggleOperator","BufferToggleSubscriber","openings","closingSelector","_error","subscription","context_2","notifyNext","outerValue","innerValue","closeBuffer","indexOf","trySubscribe","Subscription","subscribeToResult","bufferWhen","source","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","catchError","operator","CatchOperator","selector","CatchSubscriber","result","err2","innerSubscriber","combineAll","project","observables","isArray","concatMap","resultSelector","concatMapTo","CountOperator","CountSubscriber","predicate","next","debounce","DebounceOperator","DebounceSubscriber","emitValue","DebounceTimeOperator","DebounceTimeSubscriber","dueTime","clearDebounce","debouncedNext","lastValue","debouncedSubscription","defaultValue","DefaultIfEmptyOperator","DefaultIfEmptySubscriber","isDate","DelayOperator","DelaySubscriber","delay","queue","notification","delay_1","message","DelayMessage","scheduleNotification","errored","delayWhen","subscriptionDelay","SubscriptionDelayObservable","lift","DelayWhenOperator","DelayWhenSubscriber","removeSubscription","innerSub","index","delayNotifier","completed","tryComplete","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","parent","sourceSubscribed","dematerialize","DeMaterializeOperator","DeMaterializeSubscriber","distinct","DistinctOperator","DistinctSubscriber","keySelector","flushes","key","_finalizeNext","values","distinctUntilChanged","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","compare","distinctUntilKeyChanged","errorFactory","defaultErrorFactory","ThrowIfEmptyOperator","ThrowIfEmptySubscriber","e","take","TakeOperator","total","TakeSubscriber","elementAt","pipe","v","defaultIfEmpty","every","EveryOperator","thisArg","observer","EverySubscriber","notifyComplete","exhaust","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","hasCompleted","exhaustMap","ExhaustMapOperator","ExhaustMapSubscriber","notifyError","concurrent","Number","ExpandOperator","ExpandSubscriber","arg","finalize","FinallyOperator","FinallySubscriber","find","FindValueOperator","FindValueSubscriber","findIndex","first","ignoreElements","IgnoreElementsOperator","IgnoreElementsSubscriber","isEmpty","IsEmptyOperator","IsEmptySubscriber","takeLast","TakeLastOperator","TakeLastSubscriber","Array","ring","last","mapTo","MapToOperator","MapToSubscriber","x","materialize","MaterializeOperator","MaterializeSubscriber","scan","hasSeed","ScanOperator","ScanSubscriber","_seed","set","enumerable","configurable","_tryNext","error","reduce","max","comparer","y","MergeScanOperator","MergeScanSubscriber","ish","_innerSub","min","multicast","subjectFactory","connectable","Object","MulticastOperator","subject","nextSources","OnErrorResumeNextOperator","OnErrorResumeNextSubscriber","subscribeToNextSource","pairwise","PairwiseOperator","PairwiseSubscriber","pair","partition","filter","plucker","props","p","currentProp","publish","publishBehavior","publishLast","publishReplay","selectorOrScheduler","ReplaySubject","windowTime","empty","RepeatOperator","RepeatSubscriber","repeatWhen","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","_unsubscribeAndRecycle","notifications","retriesSubscription","_unsubscribe","retries","RetryOperator","RetrySubscriber","retryWhen","RetryWhenOperator","RetryWhenSubscriber","errors","sample","SampleOperator","sampleSubscriber","SampleSubscriber","SampleTimeOperator","SampleTimeSubscriber","period","dispatchNotification","sequenceEqual","SequenceEqualOperator","compareTo","SequenceEqualSubscriber","_oneComplete","_c","_b","comparator","a","shift","b","areEqual","nextB","SequenceEqualCompareToSubscriber","shareSubjectFactory","share","shareReplay","config","configOrBufferSize","refCount","shareReplayOperator","useRefCount","hasError","shareReplayOperation","isComplete","single","SingleOperator","SingleSubscriber","seenValue","skip","SkipOperator","SkipSubscriber","skipLast","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","skipCount","currentIndex","oldValue","skipUntil","SkipUntilOperator","SkipUntilSubscriber","skipWhile","SkipWhileOperator","SkipWhileSubscriber","skipping","array","SubscribeOnObservable","delayTime","asap","SubscribeOnOperator","switchMap","SwitchMapOperator","SwitchMapSubscriber","switchAll","switchMapTo","innerObservable","takeUntil","TakeUntilOperator","takeUntilSubscriber","TakeUntilSubscriber","inclusive","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","tap","nextOrObserver","DoOperator","TapSubscriber","noop","_tapComplete","_tapError","isFunction","_context","observerOrNext","_tapNext","defaultThrottleConfig","leading","trailing","ThrottleOperator","ThrottleSubscriber","send","_hasValue","_sendValue","_throttled","_trailing","throttlingDone","ThrottleTimeOperator","ThrottleTimeSubscriber","_trailingValue","_hasTrailingValue","defer","current","TimeInterval","TimeoutWithOperator","waitFor","TimeoutWithSubscriber","Timestamp","toArrayReducer","arr","toArray","window","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","subscribe","closed","Subject","prevWindow","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","c","complete","windowCreationInterval","maxWindowSize","POSITIVE_INFINITY","WindowTimeOperator","CountedSubject","WindowTimeSubscriber","windowTimeSpan","dispatchWindowClose","window_1","window_2","dispatchWindowTimeSpanOnly","dispatchWindowCreation","windowToggle","WindowToggleOperator","WindowToggleSubscriber","context_3","w","context_4","inner","windowWhen","closingNotification","args","WithLatestFromOperator","WithLatestFromSubscriber","toRespond","found","zipAll","setPrototypeOf","isNativeReflectConstruct","_construct","Parent","Class","module","exports","Reflect","construct","bind","__esModule","apply","instance","Function","fn","toString","getPrototypeOf","isNativeFunction","_wrapNativeSuper","_cache","Map","TypeError","has","get","Wrapper","constructor","create","writable"],"sourceRoot":""}